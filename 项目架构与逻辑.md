# mod_audio_stream 项目架构与逻辑

## 一、项目架构概览

### 1.1 模块组成

```
mod_audio_stream/
├── mod_audio_stream.c/h          # FreeSWITCH 模块主体
├── audio_streamer_glue.cpp/h     # C++ 音频流处理层
├── base64.cpp/h                  # Base64 编解码
└── libs/libwsc/                  # WebSocket 客户端库
```

### 1.2 架构分层

```
┌─────────────────────────────────────────────────┐
│           FreeSWITCH Core                       │
│  (通话管理、音频采集、事件系统)                 │
└────────────────┬────────────────────────────────┘
                 │ Media Bug API
┌────────────────▼────────────────────────────────┐
│      mod_audio_stream.c (C 模块层)              │
│  - API 命令注册                                  │
│  - Media Bug 回调                                │
│  - 事件触发                                      │
└────────────────┬────────────────────────────────┘
                 │ C/C++ 接口
┌────────────────▼────────────────────────────────┐
│   audio_streamer_glue.cpp (C++ 处理层)          │
│  - 音频缓冲与重采样                              │
│  - 并发控制                                      │
│  - AudioStreamer 管理                            │
└────────────────┬────────────────────────────────┘
                 │ WebSocket API
┌────────────────▼────────────────────────────────┐
│      AudioStreamer (WebSocket 封装层)            │
│  - WebSocket 连接管理                            │
│  - 消息收发                                      │
│  - 音频播放处理                                  │
└────────────────┬────────────────────────────────┘
                 │ libwsc
┌────────────────▼────────────────────────────────┐
│         WebSocketClient (libwsc)                │
│  - RFC-6455 协议实现                             │
│  - TLS 支持                                      │
│  - 压缩支持                                      │
└─────────────────────────────────────────────────┘
```

---

## 二、核心数据结构

### 2.1 private_t 结构体

```c
struct private_data {
    switch_mutex_t *mutex;              // 并发控制互斥锁
    char sessionId[256];                // 会话 UUID
    SpeexResamplerState *resampler;     // 重采样器
    responseHandler_t responseHandler;   // 事件回调函数
    void *pAudioStreamer;               // AudioStreamer 实例指针
    char ws_uri[4096];                  // WebSocket URI
    int sampling;                       // 目标采样率
    int channels;                       // 声道数
    int audio_paused:1;                 // 暂停标志
    int close_requested:1;              // 关闭请求标志
    char initialMetadata[8192];         // 初始元数据
    switch_buffer_t *sbuffer;           // 音频缓冲区
    int rtp_packets;                    // 缓冲包数
};
```

### 2.2 AudioStreamer 类

```cpp
class AudioStreamer {
private:
    std::string m_sessionId;            // 会话 ID
    responseHandler_t m_notify;         // 事件通知回调
    WebSocketClient client;             // WebSocket 客户端
    bool m_suppress_log;                // 日志抑制标志
    const char* m_extra_headers;        // 额外 HTTP 头
    int m_playFile;                     // 播放文件计数器
    std::unordered_set<std::string> m_Files;  // 临时文件集合
    
public:
    // 连接管理
    void disconnect();
    bool isConnected();
    
    // 数据发送
    void writeBinary(uint8_t* buffer, size_t len);
    void writeText(const char* text);
    
    // 事件处理
    void eventCallback(notifyEvent_t event, const char* message);
    switch_bool_t processMessage(switch_core_session_t* session, std::string& message);
    
    // 资源清理
    void deleteFiles();
};
```

---

## 三、核心流程详解

### 3.1 启动流程


```
用户调用 API
    │
    ▼
uuid_audio_stream start
    │
    ▼
stream_function() [mod_audio_stream.c]
    │
    ├─ 参数解析与验证
    │  ├─ UUID 验证
    │  ├─ WebSocket URI 验证
    │  ├─ mix-type 解析 (mono/mixed/stereo)
    │  └─ sampling-rate 解析
    │
    ▼
start_capture()
    │
    ├─ 检查是否已存在 bug
    ├─ 确保通话已 pre-answer
    │
    ▼
stream_session_init() [audio_streamer_glue.cpp]
    │
    ├─ 读取通道变量配置
    │  ├─ STREAM_BUFFER_SIZE
    │  ├─ STREAM_HEART_BEAT
    │  ├─ STREAM_EXTRA_HEADERS
    │  ├─ STREAM_TLS_* 配置
    │  └─ STREAM_MESSAGE_DEFLATE
    │
    ├─ 分配 private_t 结构体
    │
    ▼
stream_data_init()
    │
    ├─ 初始化互斥锁
    ├─ 创建音频缓冲区
    ├─ 初始化重采样器（如需要）
    │
    ▼
new AudioStreamer()
    │
    ├─ 解析额外 HTTP 头
    ├─ 配置 TLS 选项
    ├─ 设置心跳间隔
    ├─ 配置压缩选项
    │
    ├─ 注册回调函数
    │  ├─ onMessage
    │  ├─ onOpen
    │  ├─ onError
    │  └─ onClose
    │
    ▼
client.connect()
    │
    ├─ DNS 解析
    ├─ TCP 连接
    ├─ TLS 握手（如果是 wss://）
    ├─ WebSocket 握手
    │
    ▼
连接成功回调
    │
    ├─ 触发 CONNECT_SUCCESS 事件
    ├─ 发送初始元数据（如有）
    │
    ▼
switch_core_media_bug_add()
    │
    └─ 注册 capture_callback
       └─ 开始捕获音频
```

### 3.2 音频流处理流程

```
音频帧到达
    │
    ▼
capture_callback() [mod_audio_stream.c]
    │
    ├─ SWITCH_ABC_TYPE_READ 事件
    │
    ▼
stream_frame() [audio_streamer_glue.cpp]
    │
    ├─ 检查 audio_paused 标志
    │
    ├─ switch_mutex_trylock() ◄─── 非阻塞锁
    │  └─ 失败则直接返回（避免阻塞音频线程）
    │
    ▼
switch_core_media_bug_read()
    │
    ├─ 读取音频帧
    │
    ▼
是否需要重采样？
    │
    ├─ 否 ──────────────────────┐
    │                            │
    ├─ 是                        │
    │   │                        │
    │   ▼                        │
    │ speex_resampler_process    │
    │   │                        │
    │   └────────────────────────┤
    │                            │
    ▼                            ▼
缓冲策略判断
    │
    ├─ rtp_packets == 1 (20ms)
    │   └─> 直接发送
    │       └─> pAudioStreamer->writeBinary()
    │
    ├─ rtp_packets > 1 (批量发送)
    │   │
    │   ├─ 写入 switch_buffer
    │   │
    │   ├─ 缓冲区满？
    │   │   │
    │   │   ├─ 是
    │   │   │   └─> 读取全部数据
    │   │   │       └─> pAudioStreamer->writeBinary()
    │   │   │
    │   │   └─ 否
    │   │       └─> 继续缓冲
    │
    ▼
switch_mutex_unlock()
    │
    └─> 返回 SWITCH_TRUE
```

### 3.3 WebSocket 消息接收流程

```
WebSocket 收到消息
    │
    ▼
client.onMessage 回调
    │
    ▼
AudioStreamer::eventCallback(MESSAGE, message)
    │
    ├─ switch_core_session_locate() ◄─── 获取会话锁
    │
    ▼
processMessage()
    │
    ├─ 解析 JSON
    │
    ▼
type == "streamAudio" ?
    │
    ├─ 是 ──────────────────────┐
    │                            │
    │                            ▼
    │                    提取音频数据
    │                            │
    │                            ├─ audioDataType
    │                            │  ├─ raw (需要 sampleRate)
    │                            │  ├─ wav
    │                            │  ├─ mp3
    │                            │  └─ ogg
    │                            │
    │                            ▼
    │                    Base64 解码
    │                            │
    │                            ▼
    │                    生成临时文件
    │                    /tmp/{uuid}_{n}.tmp.{ext}
    │                            │
    │                            ├─ 保存到文件
    │                            ├─ 记录到 m_Files
    │                            │
    │                            ▼
    │                    触发 EVENT_PLAY 事件
    │                            │
    │                            └─> 返回 SWITCH_TRUE
    │
    ├─ 否
    │   └─> 触发 EVENT_JSON 事件
    │       └─> 返回 SWITCH_FALSE
    │
    ▼
switch_core_session_rwunlock() ◄─── 释放会话锁
```

### 3.4 停止流程

```
用户调用 stop
    │
    ▼
do_stop() [mod_audio_stream.c]
    │
    ▼
stream_session_cleanup() [audio_streamer_glue.cpp]
    │
    ├─ 获取 media bug
    │
    ├─ switch_mutex_lock() ◄─── 阻塞式锁
    │
    ├─ 设置 private 为 NULL
    │
    ├─ 移除 media bug
    │  └─> switch_core_media_bug_remove()
    │
    ▼
AudioStreamer 清理
    │
    ├─ deleteFiles()
    │  └─> 删除所有临时音频文件
    │
    ├─ writeText(final_text)
    │  └─> 发送最终消息（如有）
    │
    ▼
finish()
    │
    ├─ 创建 shared_ptr<AudioStreamer>
    │
    ├─ 启动独立线程
    │  └─> std::thread([aStreamer] {
    │         aStreamer->disconnect();
    │     });
    │
    └─> t.detach() ◄─── 异步断开连接
        │
        ▼
    WebSocket 断开
        │
        ├─ 发送 Close 帧
        ├─ 等待服务器响应
        └─> 关闭 TCP 连接
            │
            ▼
        onClose 回调
            │
            └─> 触发 EVENT_DISCONNECT 事件
```

---

## 四、并发控制机制

### 4.1 线程模型

```
┌─────────────────────┐
│  FreeSWITCH 主线程  │
│  - API 命令处理     │
│  - 会话管理         │
└──────────┬──────────┘
           │
           ├─────────────────────────────┐
           │                             │
┌──────────▼──────────┐      ┌──────────▼──────────┐
│  音频处理线程       │      │  WebSocket 线程     │
│  - capture_callback │      │  - 消息接收         │
│  - stream_frame     │      │  - 事件回调         │
│  - 音频重采样       │      │  - 连接管理         │
└──────────┬──────────┘      └──────────┬──────────┘
           │                             │
           └──────────┬──────────────────┘
                      │
           ┌──────────▼──────────┐
           │  清理线程（临时）   │
           │  - 异步断开连接     │
           └─────────────────────┘
```

### 4.2 锁策略

**1. 音频处理路径（热路径）**
```cpp
// 使用非阻塞锁，避免影响实时性
if (switch_mutex_trylock(tech_pvt->mutex) == SWITCH_STATUS_SUCCESS) {
    // 处理音频
    switch_mutex_unlock(tech_pvt->mutex);
}
// 获取失败直接返回，丢弃本次音频帧
```

**2. 清理路径（冷路径）**
```cpp
// 使用阻塞锁，确保完整清理
switch_mutex_lock(tech_pvt->mutex);
// 清理资源
switch_mutex_unlock(tech_pvt->mutex);
```

**3. 会话访问保护**
```cpp
// 通过 FreeSWITCH 的会话锁保护
switch_core_session_t* session = switch_core_session_locate(uuid);
if (session) {
    // 访问会话
    switch_core_session_rwunlock(session);  // 必须释放
}
```

### 4.3 竞态条件处理

**场景 1：音频处理与停止操作**
```
音频线程                     停止线程
    │                           │
    ├─ trylock()                │
    │  成功                     │
    │                           ├─ lock()
    │                           │  等待...
    ├─ 处理音频                 │
    │                           │
    ├─ unlock()                 │
    │                           ├─ 获得锁
    │                           ├─ pAudioStreamer = NULL
    │                           └─ unlock()
    │                           
    ├─ trylock()
    │  成功
    ├─ 检查 pAudioStreamer
    │  └─ NULL，直接返回 ◄──── 安全退出
```

**场景 2：通话挂断与 API 停止**
```cpp
// 使用 close_requested 标志协调
if (tech_pvt->close_requested) {
    return SWITCH_FALSE;  // 停止处理
}
```

---

## 五、关键技术点

### 5.1 音频重采样

**Speex 重采样器使用：**
```cpp
// 初始化
tech_pvt->resampler = speex_resampler_init(
    channels,           // 声道数
    sampling,           // 源采样率
    desiredSampling,    // 目标采样率
    SWITCH_RESAMPLE_QUALITY,  // 质量
    &err
);

// 单声道重采样
speex_resampler_process_int(
    tech_pvt->resampler,
    0,                  // 声道索引
    input_samples,      // 输入
    &in_len,           // 输入长度
    output_samples,     // 输出
    &out_len           // 输出长度
);

// 多声道交错重采样
speex_resampler_process_interleaved_int(
    tech_pvt->resampler,
    input_samples,
    &in_len,
    output_samples,
    &out_len
);
```

### 5.2 音频缓冲策略

**缓冲区大小计算：**
```cpp
// 公式：帧大小 × 采样率比 × 声道数 × 包数
const size_t buflen = (FRAME_SIZE_8000 * desiredSampling / 8000 
                       * channels * rtp_packets);

// 示例：
// - 16kHz, 单声道, 5 个包 (100ms)
// - buflen = 320 × 2 × 1 × 5 = 3200 字节
```

**批量发送逻辑：**
- `rtp_packets = 1`：每个 20ms 帧立即发送（低延迟）
- `rtp_packets > 1`：累积多个帧后批量发送（减少网络开销）

### 5.3 Base64 音频处理

**接收流程：**
```cpp
// 1. 解析 JSON
cJSON* jsonAudio = cJSON_GetObjectItem(jsonData, "audioData");

// 2. Base64 解码
std::string rawAudio = base64_decode(jsonAudio->valuestring);

// 3. 保存到临时文件
std::ofstream fstream(filePath, std::ofstream::binary);
fstream << rawAudio;
fstream.close();

// 4. 记录文件路径
m_Files.insert(filePath);

// 5. 触发播放事件
m_notify(session, EVENT_PLAY, jsonString);
```

### 5.4 WebSocket 配置

**TLS 选项：**
```cpp
WebSocketTLSOptions tls;
tls.caFile = "SYSTEM";  // 或 "NONE" 或文件路径
tls.keyFile = "/path/to/client.key";
tls.certFile = "/path/to/client.crt";
tls.disableHostnameValidation = false;
client.setTLSOptions(tls);
```

**压缩配置：**
```cpp
// 启用 per-message deflate
client.enableCompression(true);

// 禁用压缩
client.enableCompression(false);
```

**心跳配置：**
```cpp
// 每 30 秒发送 Ping
client.setPingInterval(30);
```

---

## 六、事件驱动架构

### 6.1 事件流转

```
WebSocket 事件
    │
    ▼
AudioStreamer::eventCallback()
    │
    ├─ 定位 FreeSWITCH 会话
    │  └─> switch_core_session_locate()
    │
    ▼
responseHandler() [mod_audio_stream.c]
    │
    ├─ 创建自定义事件
    │  └─> switch_event_create_subclass()
    │
    ├─ 添加通道信息
    │  └─> switch_channel_event_set_data()
    │
    ├─ 添加事件 Body
    │  └─> switch_event_add_body()
    │
    ▼
switch_event_fire()
    │
    └─> 分发到所有订阅者
        ├─> ESL 客户端
        ├─> Dialplan 应用
        └─> 其他模块
```

### 6.2 事件类型映射

| WebSocket 事件 | 内部枚举 | FreeSWITCH 事件 |
|----------------|----------|-----------------|
| onOpen | CONNECT_SUCCESS | mod_audio_stream::connect |
| onClose | CONNECTION_DROPPED | mod_audio_stream::disconnect |
| onError | CONNECT_ERROR | mod_audio_stream::error |
| onMessage (JSON) | MESSAGE | mod_audio_stream::json |
| onMessage (streamAudio) | MESSAGE | mod_audio_stream::play |

---

## 七、资源管理

### 7.1 生命周期管理

```
创建阶段
    │
    ├─ private_t (switch_core_session_alloc)
    │  └─> 会话内存池分配，会话结束自动释放
    │
    ├─ AudioStreamer (new)
    │  └─> 堆分配，需手动 delete
    │
    ├─ switch_buffer_t
    │  └─> 会话内存池分配
    │
    └─ SpeexResamplerState
       └─> 需调用 speex_resampler_destroy()

运行阶段
    │
    └─> 临时音频文件
        └─> /tmp/{uuid}_{n}.tmp.{ext}

销毁阶段
    │
    ├─ destroy_tech_pvt()
    │  ├─> speex_resampler_destroy()
    │  ├─> switch_mutex_destroy()
    │  └─> delete AudioStreamer
    │
    └─> deleteFiles()
        └─> 删除所有临时文件
```

### 7.2 内存安全

**1. 避免悬空指针**
```cpp
// 清理时先置空，再异步销毁
tech_pvt->pAudioStreamer = nullptr;
finish(tech_pvt);  // 异步断开
```

**2. 智能指针管理**
```cpp
// 使用 shared_ptr 延长生命周期
std::shared_ptr<AudioStreamer> aStreamer;
aStreamer.reset((AudioStreamer *)tech_pvt->pAudioStreamer);
// 即使 tech_pvt 被销毁，aStreamer 仍有效
```

**3. 会话锁保护**
```cpp
// 确保会话有效性
switch_core_session_t* session = switch_core_session_locate(uuid);
if (session) {
    // 安全访问
    switch_core_session_rwunlock(session);
}
```

---

## 八、性能优化

### 8.1 零拷贝优化

```cpp
// 直接从 media bug 读取到发送缓冲区
uint8_t data_buf[SWITCH_RECOMMENDED_BUFFER_SIZE];
switch_frame_t frame = {0};
frame.data = data_buf;  // 栈上分配

// 无需重采样时直接发送
if (nullptr == tech_pvt->resampler) {
    pAudioStreamer->writeBinary((uint8_t *)frame.data, frame.datalen);
}
```

### 8.2 批量发送优化

```cpp
// 累积多个 RTP 包后一次性发送
// 减少系统调用和网络开销
if (0 == switch_buffer_freespace(tech_pvt->sbuffer)) {
    // 缓冲区满，批量发送
    switch_size_t inuse = switch_buffer_inuse(tech_pvt->sbuffer);
    std::vector<uint8_t> tmp(inuse);
    switch_buffer_read(tech_pvt->sbuffer, tmp.data(), inuse);
    pAudioStreamer->writeBinary(tmp.data(), inuse);
}
```

### 8.3 非阻塞设计

```cpp
// 音频线程使用 trylock，避免阻塞
if (switch_mutex_trylock(tech_pvt->mutex) == SWITCH_STATUS_SUCCESS) {
    // 处理
    switch_mutex_unlock(tech_pvt->mutex);
}
// 失败直接返回，不影响实时性
```

---

## 九、错误处理

### 9.1 连接错误

```cpp
client.setErrorCallback([this](int code, const std::string &msg) {
    // 构造错误事件
    cJSON *root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "status", "error");
    cJSON *message = cJSON_CreateObject();
    cJSON_AddNumberToObject(message, "code", code);
    cJSON_AddStringToObject(message, "error", msg.c_str());
    cJSON_AddItemToObject(root, "message", message);
    
    // 触发事件
    eventCallback(CONNECT_ERROR, json_str);
    
    // 关闭 media bug
    media_bug_close(psession);
});
```

### 9.2 UTF-8 验证

```cpp
switch_status_t is_valid_utf8(const char *str) {
    while (*str) {
        if ((*str & 0x80) == 0x00) {
            str++;  // 1-byte
        } else if ((*str & 0xE0) == 0xC0) {
            if ((str[1] & 0xC0) != 0x80) return SWITCH_STATUS_FALSE;
            str += 2;  // 2-byte
        } else if ((*str & 0xF0) == 0xE0) {
            if ((str[1] & 0xC0) != 0x80 || (str[2] & 0xC0) != 0x80)
                return SWITCH_STATUS_FALSE;
            str += 3;  // 3-byte
        } else if ((*str & 0xF8) == 0xF0) {
            if ((str[1] & 0xC0) != 0x80 || (str[2] & 0xC0) != 0x80 
                || (str[3] & 0xC0) != 0x80)
                return SWITCH_STATUS_FALSE;
            str += 4;  // 4-byte
        } else {
            return SWITCH_STATUS_FALSE;
        }
    }
    return SWITCH_STATUS_SUCCESS;
}
```

---

## 十、总结

### 10.1 设计亮点

1. **分层架构**：C 模块层、C++ 处理层、WebSocket 封装层清晰分离
2. **并发安全**：多层次锁机制，热路径非阻塞设计
3. **资源管理**：智能指针、异步清理、自动文件删除
4. **性能优化**：零拷贝、批量发送、可配置缓冲
5. **事件驱动**：完整的事件通知机制，便于集成

### 10.2 技术栈

- **FreeSWITCH**：媒体处理框架
- **libwsc**：轻量级 WebSocket 客户端（libevent 基础）
- **Speex DSP**：音频重采样
- **OpenSSL**：TLS 加密
- **cJSON**：JSON 解析

### 10.3 适用场景

- 实时语音识别（ASR）
- 实时语音合成（TTS）
- 语音分析与处理
- 智能语音助手
- 呼叫中心质检
- 语音翻译

---

**文档版本**：v1.0  
**最后更新**：2025-02-22
