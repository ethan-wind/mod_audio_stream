# 自动播放功能分析

## 功能描述

根据 README.md 中的描述（Update 22/2/2025）：

> **Playback feature allows continuous forward streaming while the playback runs independently.**
> 
> 播放功能允许在播放运行时进行连续的前向流传输。

这意味着：
- **双向独立**：下行（FreeSWITCH → 客户端）和上行（客户端 → FreeSWITCH）可以同时进行
- **自动播放**：接收到的音频自动播放，无需应用层干预
- **连续流式**：支持持续的音频流，而不是单次播放

---

## 当前实现状态

### 当前代码（非自动播放）

```cpp
// audio_streamer_glue.cpp - processMessage()
if (jsonFile) {
    // 保存为 WAV 文件
    // ...
    
    // 触发 EVENT_PLAY 事件
    m_notify(session, EVENT_PLAY, jsonString);
}
```

**流程**：
```
接收音频 → 保存 WAV 文件 → 触发 EVENT_PLAY 事件 → 应用层监听事件 → 调用 playback
```

**问题**：
- ❌ 需要应用层（Dialplan/ESL）监听事件并调用播放
- ❌ 不是真正的"自动"播放
- ❌ 有延迟（文件 I/O + 事件传递）
- ❌ 不支持连续流式播放

---

## v1.0.3 自动播放功能（预期实现）

### 预期行为

根据文档描述，v1.0.3 应该实现：

1. **自动播放**：接收到音频后自动播放到通话中
2. **独立运行**：播放和下行流传输互不干扰
3. **全双工**：真正的双向音频流
4. **流式播放**：支持连续的音频流

### 可能的实现方式

#### 方式 1: Media Bug WRITE（最可能）

```cpp
// 在 capture_callback 中处理 WRITE 事件
case SWITCH_ABC_TYPE_WRITE:
    // 从播放缓冲区读取音频
    // 直接写入通话
    return stream_play_frame(bug, tech_pvt);
```

**优点**：
- ✅ 真正的自动播放
- ✅ 无需应用层干预
- ✅ 延迟极低
- ✅ 支持流式播放

#### 方式 2: 后台播放线程

```cpp
// 创建独立的播放线程
std::thread play_thread([tech_pvt]() {
    while (playing) {
        // 从缓冲区读取音频
        // 使用 switch_core_session_write_frame 播放
    }
});
```

**优点**：
- ✅ 独立运行
- ✅ 灵活控制

**缺点**：
- ❌ 线程管理复杂
- ❌ 可能有同步问题

---

## 当前代码中的线索

### 1. EVENT_PLAY 事件

```cpp
// mod_audio_stream.h
#define EVENT_PLAY "mod_audio_stream::play"

// audio_streamer_glue.cpp
m_notify(session, EVENT_PLAY, jsonString);
```

**当前用途**：通知应用层有音频需要播放

**v1.0.3 可能的变化**：
- 可能仍然触发事件（用于跟踪）
- 但播放自动进行，无需应用层处理

### 2. 播放控制 API

README 中提到：
> Playback can be **tracked, paused, or resumed** dynamically.

这暗示可能有以下 API：

```c
// 可能的新 API
uuid_audio_stream <uuid> play_pause
uuid_audio_stream <uuid> play_resume
uuid_audio_stream <uuid> play_status
```

### 3. 数据结构

当前 `private_t` 结构可能需要添加：

```cpp
struct private_data {
    // ... 现有字段 ...
    
    // 播放相关（v1.0.3 可能添加）
    switch_buffer_t *play_buffer;      // 播放缓冲区
    switch_mutex_t *play_mutex;        // 播放互斥锁
    int play_paused:1;                 // 播放暂停标志
    int auto_play_enabled:1;           // 自动播放启用标志
};
```

---

## 如何实现自动播放

### 完整实现方案

#### 1. 修改数据结构

```cpp
// mod_audio_stream.h
struct private_data {
    // ... 现有字段 ...
    
    // 播放支持
    switch_buffer_t *play_buffer;
    switch_mutex_t *play_mutex;
    int play_paused:1;
    int auto_play_enabled:1;
    uint32_t play_sample_rate;
};
```

#### 2. 初始化播放缓冲区

```cpp
// audio_streamer_glue.cpp - stream_data_init()
// 创建播放缓冲区（1秒）
size_t play_buflen = desiredSampling * channels * sizeof(int16_t);
switch_buffer_create(pool, &tech_pvt->play_buffer, play_buflen);
switch_mutex_init(&tech_pvt->play_mutex, SWITCH_MUTEX_NESTED, pool);

// 默认启用自动播放
tech_pvt->auto_play_enabled = 1;
tech_pvt->play_paused = 0;
tech_pvt->play_sample_rate = desiredSampling;
```

#### 3. 注册 WRITE 回调

```c
// mod_audio_stream.c - start_capture()
// 添加 WRITE 标志
switch_media_bug_flag_t flags = SMBF_READ_STREAM | SMBF_WRITE_STREAM;

switch_core_media_bug_add(session, MY_BUG_NAME, NULL,
                          capture_callback, pUserData, 0, flags, &bug);
```

#### 4. 处理 WRITE 事件

```c
// mod_audio_stream.c - capture_callback()
case SWITCH_ABC_TYPE_WRITE:
    if (tech_pvt->auto_play_enabled && !tech_pvt->play_paused) {
        return stream_play_frame(bug, tech_pvt);
    }
    break;
```

#### 5. 实现播放函数

```cpp
// audio_streamer_glue.cpp
switch_bool_t stream_play_frame(
    switch_media_bug_t *bug,
    private_t *tech_pvt
) {
    if (!tech_pvt->play_buffer) {
        return SWITCH_TRUE;
    }

    switch_mutex_lock(tech_pvt->play_mutex);

    size_t inuse = switch_buffer_inuse(tech_pvt->play_buffer);
    
    if (inuse > 0) {
        // 计算一帧大小（20ms）
        size_t frame_size = tech_pvt->play_sample_rate * 
                           tech_pvt->channels * 2 / 50;
        
        if (inuse >= frame_size) {
            uint8_t data[SWITCH_RECOMMENDED_BUFFER_SIZE];
            switch_buffer_read(tech_pvt->play_buffer, data, frame_size);
            
            // 准备音频帧
            switch_frame_t frame = {0};
            frame.data = data;
            frame.datalen = frame_size;
            frame.samples = frame_size / (tech_pvt->channels * 2);
            frame.rate = tech_pvt->play_sample_rate;
            frame.channels = tech_pvt->channels;
            
            // 写入 Media Bug（自动播放）
            switch_core_media_bug_write_frame(bug, &frame);
        }
    }

    switch_mutex_unlock(tech_pvt->play_mutex);
    return SWITCH_TRUE;
}
```

#### 6. 接收音频时写入缓冲区

```cpp
// audio_streamer_glue.cpp - processMessage()
if (tech_pvt->auto_play_enabled) {
    // Float32 → 16-bit PCM
    // 重采样到播放采样率
    // ...
    
    // 写入播放缓冲区（自动播放）
    switch_mutex_lock(tech_pvt->play_mutex);
    switch_buffer_write(tech_pvt->play_buffer,
                       (uint8_t*)pcm_data.data(),
                       pcm_data.size() * sizeof(int16_t));
    switch_mutex_unlock(tech_pvt->play_mutex);
    
    // 仍然触发事件（用于跟踪）
    m_notify(session, EVENT_PLAY, jsonString);
}
```

#### 7. 播放控制 API

```c
// mod_audio_stream.c
// 新增 API 命令
if (!strcasecmp(argv[1], "play_pause")) {
    tech_pvt->play_paused = 1;
    stream.write_function(&stream, "+OK paused\n");
}
else if (!strcasecmp(argv[1], "play_resume")) {
    tech_pvt->play_paused = 0;
    stream.write_function(&stream, "+OK resumed\n");
}
else if (!strcasecmp(argv[1], "play_status")) {
    size_t inuse = switch_buffer_inuse(tech_pvt->play_buffer);
    double duration = (double)inuse / (tech_pvt->play_sample_rate * 
                                       tech_pvt->channels * 2) * 1000.0;
    stream.write_function(&stream, "+OK buffered: %.2f ms\n", duration);
}
```

---

## 使用示例

### 启动自动播放

```javascript
// 启动音频流，自动播放默认启用
uuid_audio_stream <uuid> start ws://server/path sampling=16000
```

### 客户端发送音频（自动播放）

```json
{
  "type": "streamAudio",
  "data": {
    "audioDataType": "raw",
    "sampleRate": 24000,
    "audioData": "<base64_float32>"
  }
}
```

音频会自动播放到通话中，无需应用层干预。

### 控制播放

```javascript
// 暂停播放
uuid_audio_stream <uuid> play_pause

// 恢复播放
uuid_audio_stream <uuid> play_resume

// 查看播放状态
uuid_audio_stream <uuid> play_status
```

---

## 与当前实现的对比

| 特性 | 当前实现 | v1.0.3 自动播放 |
|------|---------|----------------|
| **播放方式** | 保存文件 → 应用层播放 | 直接流式播放 |
| **是否自动** | ❌ 需要应用层干预 | ✅ 完全自动 |
| **延迟** | 50-200ms | 20-40ms |
| **磁盘 I/O** | ✅ 需要 | ❌ 不需要 |
| **双向独立** | ❌ 不支持 | ✅ 完全独立 |
| **流式播放** | ❌ 不支持 | ✅ 支持 |
| **播放控制** | ❌ 无 | ✅ 暂停/恢复/状态 |

---

## 总结

### 当前代码状态

当前代码库中**没有实现自动播放功能**，只有：
- 接收音频 → 保存 WAV 文件 → 触发 `EVENT_PLAY` 事件
- 需要应用层监听事件并调用 `playback` 应用

### v1.0.3 预期功能

根据文档描述，v1.0.3 应该实现：
- ✅ 自动播放（无需应用层干预）
- ✅ 流式播放（连续音频流）
- ✅ 双向独立（下行和上行同时进行）
- ✅ 播放控制（暂停/恢复/跟踪）

### 实现建议

要实现自动播放功能，需要：
1. 添加播放缓冲区和互斥锁
2. 注册 `SWITCH_ABC_TYPE_WRITE` 回调
3. 实现 `stream_play_frame()` 函数
4. 修改 `processMessage()` 写入播放缓冲区
5. 添加播放控制 API

这样就可以实现真正的**自动流式播放**，无需应用层干预！

---

## 参考文档

- [直接播放音频流方案.md](./直接播放音频流方案.md) - 详细的实现方案
- [音频流双向处理说明.md](./音频流双向处理说明.md) - 双向音频流说明
- [下行音频处理详细分析.md](./下行音频处理详细分析.md) - 下行处理分析
