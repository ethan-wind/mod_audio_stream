# mod_audio_stream 对接文档

## 项目概述

`mod_audio_stream` 是一个 FreeSWITCH 模块，用于将通话音频实时流式传输到 WebSocket 服务器，并可接收服务器返回的音频进行播放。主要用于对接 ASR（语音识别）、TTS（语音合成）等实时语音处理服务。

### 核心特性
- **实时音频流传输**：将通话音频以 L16 格式流式发送到 WebSocket
- **双向流式通信**：支持接收 WebSocket 返回的音频并播放
- **多种音频模式**：支持单声道（mono）、混音（mixed）、立体声（stereo）
- **灵活采样率**：支持 8kHz、16kHz 等多种采样率，自动重采样
- **压缩传输**：支持 per-message deflate 压缩，节省带宽
- **TLS 支持**：支持 WSS 安全连接

---

## 一、安装部署

### 1.1 依赖项
```bash
# Debian/Ubuntu
sudo apt-get install libfreeswitch-dev libssl-dev zlib1g-dev libevent-dev libspeexdsp-dev
```

### 1.2 编译安装
```bash
# 克隆项目
git clone https://github.com/amigniter/mod_audio_stream.git
cd mod_audio_stream

# 初始化子模块
git submodule init
git submodule update

# 编译（默认不支持 TLS）
mkdir build && cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
make
sudo make install

# 如需 TLS 支持
cmake -DCMAKE_BUILD_TYPE=Release -DUSE_TLS=ON ..
```

### 1.3 FreeSWITCH 配置
在 FreeSWITCH 的 `modules.conf.xml` 中加载模块：
```xml
<load module="mod_audio_stream"/>
```

重启 FreeSWITCH 或执行：
```
fs_cli> reload mod_audio_stream
```

---

## 二、API 命令

### 2.1 启动音频流
```
uuid_audio_stream <uuid> start <wss-url> <mix-type> <sampling-rate> [metadata]
```

**参数说明：**
- `uuid`：FreeSWITCH 通话的唯一标识符
- `wss-url`：WebSocket 服务器地址（支持 `ws://` 或 `wss://`）
- `mix-type`：音频混合模式
  - `mono`：单声道，仅包含主叫方音频
  - `mixed`：单声道，包含主叫和被叫混音
  - `stereo`：立体声，左声道主叫，右声道被叫
- `sampling-rate`：采样率
  - `8k`：8000 Hz
  - `16k`：16000 Hz
  - 或直接指定数值（必须是 8000 的倍数）
- `metadata`：（可选）初始元数据，UTF-8 文本，连接成功后首先发送

**示例：**
```bash
# 单声道 8kHz
uuid_audio_stream 12345-uuid start ws://localhost:8080/audio mono 8k

# 立体声 16kHz 带元数据
uuid_audio_stream 12345-uuid start wss://api.example.com/stream stereo 16k '{"session":"abc123"}'
```

### 2.2 发送文本消息
```
uuid_audio_stream <uuid> send_text <text>
```

向 WebSocket 服务器发送文本消息（UTF-8 格式）。

**示例：**
```bash
uuid_audio_stream 12345-uuid send_text '{"command":"start_recognition"}'
```

### 2.3 停止音频流
```
uuid_audio_stream <uuid> stop [metadata]
```

停止音频流并关闭 WebSocket 连接。可选的 `metadata` 会在关闭前发送。

**示例：**
```bash
uuid_audio_stream 12345-uuid stop '{"reason":"call_ended"}'
```

### 2.4 暂停/恢复
```
uuid_audio_stream <uuid> pause
uuid_audio_stream <uuid> resume
```

暂停或恢复音频流传输（WebSocket 连接保持）。

---

## 三、通道变量配置

在启动音频流前，可通过设置通道变量来调整行为：

### 3.1 基础配置

| 变量名 | 说明 | 默认值 | 示例 |
|--------|------|--------|------|
| `STREAM_MESSAGE_DEFLATE` | 禁用压缩（设为 true/1） | 启用 | `true` |
| `STREAM_HEART_BEAT` | 心跳间隔（秒） | 关闭 | `30` |
| `STREAM_SUPPRESS_LOG` | 抑制日志输出 | false | `true` |
| `STREAM_BUFFER_SIZE` | 缓冲时长（毫秒，20的倍数） | 20 | `100` |
| `STREAM_EXTRA_HEADERS` | 额外 HTTP 头（JSON） | 无 | 见下文 |

### 3.2 TLS 配置

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| `STREAM_TLS_CA_FILE` | CA 证书文件路径 | `SYSTEM` |
| `STREAM_TLS_KEY_FILE` | 客户端密钥文件 | 无 |
| `STREAM_TLS_CERT_FILE` | 客户端证书文件 | 无 |
| `STREAM_TLS_DISABLE_HOSTNAME_VALIDATION` | 禁用主机名验证 | false |

**TLS CA 文件特殊值：**
- `SYSTEM`：使用系统默认 CA 证书
- `NONE`：不验证服务器证书（不推荐）

### 3.3 配置示例

**Dialplan 配置：**
```xml
<extension name="audio_stream_test">
  <condition field="destination_number" expression="^9999$">
    <!-- 设置通道变量 -->
    <action application="set" data="STREAM_BUFFER_SIZE=100"/>
    <action application="set" data="STREAM_HEART_BEAT=30"/>
    <action application="set" data="STREAM_EXTRA_HEADERS={'Authorization':'Bearer token123','X-Session-ID':'abc'}"/>
    
    <!-- 应答通话 -->
    <action application="answer"/>
    
    <!-- 启动音频流 -->
    <action application="uuid_audio_stream" data="${uuid} start wss://api.example.com/stream stereo 16k"/>
    
    <!-- 保持通话 -->
    <action application="park"/>
  </condition>
</extension>
```

**ESL 脚本配置：**
```python
import ESL

con = ESL.ESLconnection("localhost", "8021", "ClueCon")

# 设置通道变量
con.api("uuid_setvar", f"{uuid} STREAM_BUFFER_SIZE 100")
con.api("uuid_setvar", f"{uuid} STREAM_HEART_BEAT 30")

# 启动音频流
con.api("uuid_audio_stream", f"{uuid} start ws://localhost:8080/audio mono 8k")
```

---

## 四、WebSocket 服务器端对接

### 4.1 接收音频数据

**音频格式：**
- **编码**：L16（Linear PCM 16-bit）
- **字节序**：小端（Little Endian）
- **采样率**：根据启动命令指定（8000 或 16000 Hz）
- **声道数**：
  - mono/mixed：1 声道
  - stereo：2 声道（交错存储）
- **传输方式**：WebSocket Binary 消息

**数据包大小：**
- 默认 20ms 音频帧：320 字节（8kHz 单声道）或 640 字节（16kHz 单声道）
- 可通过 `STREAM_BUFFER_SIZE` 调整

**服务器端示例（Node.js）：**
```javascript
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  console.log('Client connected');
  
  ws.on('message', (message) => {
    if (message instanceof Buffer) {
      // 接收到音频数据（二进制）
      console.log(`Received audio: ${message.length} bytes`);
      
      // 处理音频数据（如发送到 ASR 引擎）
      processAudio(message);
    } else {
      // 接收到文本消息
      console.log('Received text:', message.toString());
      const data = JSON.parse(message.toString());
      // 处理元数据
    }
  });
  
  ws.on('close', () => {
    console.log('Client disconnected');
  });
});
```

### 4.2 发送音频回放

服务器可以发送 JSON 消息，让 FreeSWITCH 播放音频：

**消息格式：**
```json
{
  "type": "streamAudio",
  "data": {
    "audioDataType": "raw",
    "sampleRate": 8000,
    "audioData": "<base64编码的音频数据>"
  }
}
```

**字段说明：**
- `type`：固定为 `"streamAudio"`
- `audioDataType`：音频类型
  - `raw`：原始 PCM（需指定 sampleRate）
  - `wav`：WAV 文件
  - `mp3`：MP3 文件
  - `ogg`：OGG 文件
- `sampleRate`：采样率（仅 raw 类型需要）
  - 支持：8000, 16000, 24000, 32000, 48000, 64000
- `audioData`：Base64 编码的音频数据

**服务器端示例：**
```javascript
// 发送 TTS 音频回放
function sendAudio(ws, audioBuffer, sampleRate = 8000) {
  const base64Audio = audioBuffer.toString('base64');
  
  const message = {
    type: 'streamAudio',
    data: {
      audioDataType: 'raw',
      sampleRate: sampleRate,
      audioData: base64Audio
    }
  };
  
  ws.send(JSON.stringify(message));
}
```

### 4.3 发送其他响应

服务器可以发送任意 JSON 消息，FreeSWITCH 会触发相应事件：

```javascript
// 发送识别结果
ws.send(JSON.stringify({
  type: 'recognition',
  result: {
    text: '你好世界',
    confidence: 0.95
  }
}));
```

---

## 五、事件监听

FreeSWITCH 会触发以下自定义事件，可通过 ESL 或 Dialplan 监听：

### 5.1 连接成功事件
**事件名**：`mod_audio_stream::connect`

**Body（JSON）：**
```json
{
  "status": "connected"
}
```

### 5.2 断开连接事件
**事件名**：`mod_audio_stream::disconnect`

**Body（JSON）：**
```json
{
  "status": "disconnected",
  "message": {
    "code": 1000,
    "reason": "Normal closure"
  }
}
```

### 5.3 错误事件
**事件名**：`mod_audio_stream::error`

**Body（JSON）：**
```json
{
  "status": "error",
  "message": {
    "code": 6,
    "error": "Connect failed"
  }
}
```

**错误代码：**
| Code | 名称 | 说明 |
|------|------|------|
| 1 | IO | I/O 读写错误 |
| 2 | INVALID_HEADER | 服务器发送的头部格式错误 |
| 3 | SERVER_MASKED | 服务器帧被掩码（违反规范） |
| 4 | NOT_SUPPORTED | 不支持的功能 |
| 5 | PING_TIMEOUT | PONG 超时 |
| 6 | CONNECT_FAILED | TCP 连接或 DNS 查询失败 |
| 7 | TLS_INIT_FAILED | SSL/TLS 初始化失败 |
| 8 | SSL_HANDSHAKE_FAILED | SSL/TLS 握手失败 |
| 9 | SSL_ERROR | SSL/TLS 通用错误 |

### 5.4 JSON 消息事件
**事件名**：`mod_audio_stream::json`

**Body**：WebSocket 服务器发送的原始 JSON 内容

### 5.5 音频播放事件
**事件名**：`mod_audio_stream::play`

**Body（JSON）：**
```json
{
  "audioDataType": "raw",
  "sampleRate": 8000,
  "file": "/tmp/12345-uuid_0.tmp.r8"
}
```

### 5.6 ESL 监听示例

```python
import ESL

con = ESL.ESLconnection("localhost", "8021", "ClueCon")

# 订阅事件
con.events("plain", "CUSTOM mod_audio_stream::json")
con.events("plain", "CUSTOM mod_audio_stream::connect")
con.events("plain", "CUSTOM mod_audio_stream::error")

while True:
    e = con.recvEvent()
    if e:
        event_name = e.getHeader("Event-Subclass")
        body = e.getBody()
        print(f"Event: {event_name}")
        print(f"Body: {body}")
```

---

## 六、完整对接流程

### 6.1 典型 ASR 对接流程

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│  FreeSWITCH │         │  WebSocket   │         │  ASR 引擎   │
│             │         │   服务器     │         │             │
└──────┬──────┘         └──────┬───────┘         └──────┬──────┘
       │                       │                        │
       │ 1. 建立 WS 连接       │                        │
       ├──────────────────────>│                        │
       │                       │                        │
       │ 2. 发送初始元数据     │                        │
       ├──────────────────────>│                        │
       │                       │                        │
       │ 3. 流式发送音频       │  4. 转发到 ASR         │
       ├──────────────────────>├───────────────────────>│
       │   (Binary frames)     │                        │
       │                       │                        │
       │                       │  5. 返回识别结果       │
       │  6. 触发 JSON 事件    │<───────────────────────┤
       │<──────────────────────┤   (JSON)               │
       │                       │                        │
       │ 7. 停止流式传输       │                        │
       ├──────────────────────>│                        │
       │                       │                        │
       │ 8. 关闭连接           │                        │
       │<──────────────────────┤                        │
       │                       │                        │
```

### 6.2 双向流式 TTS 对接流程

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│  FreeSWITCH │         │  WebSocket   │         │  TTS 引擎   │
│             │         │   服务器     │         │             │
└──────┬──────┘         └──────┬───────┘         └──────┬──────┘
       │                       │                        │
       │ 1. 建立连接并发送文本 │                        │
       ├──────────────────────>│  2. 请求 TTS           │
       │                       ├───────────────────────>│
       │                       │                        │
       │                       │  3. 返回音频流         │
       │  4. 播放音频          │<───────────────────────┤
       │<──────────────────────┤   (streamAudio)        │
       │   (触发 play 事件)    │                        │
       │                       │                        │
       │ 5. 继续发送用户语音   │  6. 实时 ASR           │
       ├──────────────────────>├───────────────────────>│
       │                       │                        │
```

### 6.3 Dialplan 完整示例

```xml
<extension name="智能语音助手">
  <condition field="destination_number" expression="^8888$">
    <!-- 应答 -->
    <action application="answer"/>
    
    <!-- 配置音频流参数 -->
    <action application="set" data="STREAM_BUFFER_SIZE=60"/>
    <action application="set" data="STREAM_HEART_BEAT=30"/>
    <action application="set" data="STREAM_EXTRA_HEADERS={'X-API-Key':'your-api-key'}"/>
    
    <!-- 启动音频流 -->
    <action application="uuid_audio_stream" 
            data="${uuid} start wss://ai.example.com/voice mono 16k {'caller':'${caller_id_number}'}"/>
    
    <!-- 播放欢迎语 -->
    <action application="playback" data="ivr/welcome.wav"/>
    
    <!-- 保持通话，等待用户挂断 -->
    <action application="park"/>
  </condition>
</extension>
```

---

## 七、注意事项与最佳实践

### 7.1 性能优化
1. **缓冲区大小**：根据网络延迟调整 `STREAM_BUFFER_SIZE`
   - 低延迟网络：20-60ms
   - 高延迟网络：100-200ms

2. **压缩**：在带宽受限时启用压缩，但会增加 CPU 开销

3. **采样率**：根据实际需求选择
   - 语音识别：8kHz 通常足够
   - 高质量场景：16kHz

### 7.2 安全建议
1. 生产环境使用 `wss://`（TLS 加密）
2. 通过 `STREAM_EXTRA_HEADERS` 传递认证令牌
3. 不要禁用主机名验证（除非测试环境）

### 7.3 错误处理
1. 监听 `mod_audio_stream::error` 事件
2. 连接失败时自动重试或转人工
3. 记录详细日志便于排查问题

### 7.4 资源清理
- 通话结束时自动清理临时音频文件
- 确保调用 `stop` 命令正确关闭连接
- 避免长时间 park 导致资源泄漏

### 7.5 并发限制
- 免费版限制 **10 个并发流**
- 超过限制需联系商业授权

---

## 八、故障排查

### 8.1 连接失败
```bash
# 检查模块是否加载
fs_cli> module_exists mod_audio_stream

# 查看详细日志
fs_cli> console loglevel debug
fs_cli> uuid_audio_stream <uuid> start ws://...

# 检查网络连通性
curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Version: 13" -H "Sec-WebSocket-Key: test" \
  http://your-server:port/path
```

### 8.2 音频无数据
1. 确认通话已应答（pre-answer 或 answer）
2. 检查 mix-type 是否正确
3. 验证 WebSocket 服务器是否正常接收

### 8.3 TLS 证书问题
```bash
# 测试证书
openssl s_client -connect your-server:443 -showcerts

# 使用自签名证书
<action application="set" data="STREAM_TLS_CA_FILE=/path/to/ca.crt"/>
```

---

## 九、技术支持

- **GitHub**：https://github.com/amigniter/mod_audio_stream
- **Issues**：提交 Bug 或功能请求
- **商业支持**：amsoftswitch@gmail.com

---

**文档版本**：v1.0.3  
**最后更新**：2025-02-22
