# 流式播放音频格式分析

## 当前实现的音频流转换链路

### 完整转换流程

```
客户端上传
    ↓
Float32, 24000Hz, 单声道
    ↓
Base64 解码
    ↓
Float32 数据（原始）
    ↓
【转换步骤 1】Float32 → 16-bit PCM
    sample_16bit = sample_float32 * 32767
    ↓
16-bit PCM, 24000Hz, 单声道（转换后）
    ↓
【转换步骤 2】重采样到通话采样率
    24000Hz → tech_pvt->sampling (如 16000Hz)
    ↓
16-bit PCM, 16000Hz, 单声道（最终格式）
    ↓
写入播放缓冲区
    ↓
Media Bug WRITE 回调
    ↓
播放到通话中
```

---

## 回答：播放的是转换之后的语音流

### ✅ 当前流式播放使用的是：**转换之后**的语音流

**证据**：

```cpp
// 步骤 1: Float32 → 16-bit PCM
const float* float_data = reinterpret_cast<const float*>(rawAudio.data());
for (size_t i = 0; i < input_samples; i++) {
    float sample = float_data[i];
    if (sample > 1.0f) sample = 1.0f;
    if (sample < -1.0f) sample = -1.0f;
    pcm16bit[i] = static_cast<int16_t>(sample * 32767.0f);  // ← 转换
}

// 步骤 2: 重采样
speex_resampler_process_int(resampler, 0,
                            pcm16bit.data(),      // ← 使用转换后的数据
                            &in_len,
                            playbackSamples.data(),
                            &out_len);

// 步骤 3: 写入播放缓冲区
switch_buffer_write(tech_pvt->play_buffer,
                   (uint8_t*)playbackSamples.data(),  // ← 转换+重采样后的数据
                   data_size);
```

---

## 详细分析

### 输入格式（客户端上传）

```
格式: Float32
采样率: 24000 Hz
声道: 单声道
位深度: 32-bit
字节序: 小端序
数值范围: -1.0 到 1.0
```

### 转换步骤

#### 步骤 1: Float32 → 16-bit PCM

**位置**: `audio_streamer_glue.cpp` 第 340-355 行

```cpp
// 输入: Float32 数据
const float* float_data = reinterpret_cast<const float*>(rawAudio.data());

// 转换
for (size_t i = 0; i < input_samples; i++) {
    float sample = float_data[i];
    
    // 限幅
    if (sample > 1.0f) sample = 1.0f;
    if (sample < -1.0f) sample = -1.0f;
    
    // Float32 → 16-bit PCM
    pcm16bit[i] = static_cast<int16_t>(sample * 32767.0f);
}

// 输出: 16-bit PCM, 24000Hz
```

**转换公式**：
```
int16_value = clamp(float_value, -1.0, 1.0) × 32767
```

**示例**：
| Float32 输入 | 16-bit PCM 输出 |
|-------------|----------------|
| 0.0         | 0              |
| 0.5         | 16384          |
| 1.0         | 32767          |
| -1.0        | -32767         |

#### 步骤 2: 重采样 24000Hz → 通话采样率

**位置**: `audio_streamer_glue.cpp` 第 372-390 行

```cpp
// 输入: 16-bit PCM, 24000Hz
int target_rate = tech_pvt->sampling;  // 如 16000Hz

speex_resampler_process_int(resampler, 0,
                            pcm16bit.data(),        // 输入：16-bit PCM
                            &in_len,
                            playbackSamples.data(), // 输出：16-bit PCM
                            &out_len);

// 输出: 16-bit PCM, 16000Hz
```

**重采样比例**：
```
24000Hz → 16000Hz
比例: 24000 / 16000 = 3:2
样本数: 2400 samples → 1600 samples
```

#### 步骤 3: 写入播放缓冲区

**位置**: `audio_streamer_glue.cpp` 第 397-402 行

```cpp
// 输入: 16-bit PCM, 16000Hz
switch_buffer_write(tech_pvt->play_buffer,
                   (uint8_t*)playbackSamples.data(),
                   data_size);

// 存储格式: 16-bit PCM, 16000Hz, 小端序
```

### 播放格式（最终）

```
格式: 16-bit PCM (int16)
采样率: 16000 Hz（或通话采样率）
声道: 单声道
位深度: 16-bit
字节序: 小端序
```

---

## 为什么要转换？

### 1. FreeSWITCH 要求 16-bit PCM

FreeSWITCH 的 Media Bug 接口要求：
- 格式：16-bit signed PCM
- 字节序：小端序
- 不支持 Float32 直接播放

### 2. 采样率匹配

通话采样率可能是：
- 8000 Hz（窄带）
- 16000 Hz（宽带）
- 48000 Hz（超宽带）

必须重采样到通话采样率才能正确播放。

### 3. 性能优化

16-bit PCM 比 Float32 更高效：
- 内存占用减半（2 bytes vs 4 bytes）
- CPU 处理更快
- 与 FreeSWITCH 内部格式一致

---

## 数据流对比

### 原始数据（不转换）

```
Float32, 24000Hz
    ↓
❌ 无法直接播放
```

### 当前实现（转换后）

```
Float32, 24000Hz
    ↓ [转换]
16-bit PCM, 24000Hz
    ↓ [重采样]
16-bit PCM, 16000Hz
    ↓ [播放]
✅ 正确播放
```

---

## 转换的性能影响

### CPU 使用

```
Float32 → 16-bit PCM: < 0.1ms (简单乘法)
重采样 24000→16000: 0.5-1ms (SpeexDSP)
总计: < 1.5ms
```

### 内存使用

```
输入: Float32, 24000 samples = 96 KB
转换: 16-bit PCM, 24000 samples = 48 KB (减半)
重采样: 16-bit PCM, 16000 samples = 32 KB
总计: 节省 67% 内存
```

### 音质影响

```
Float32 → 16-bit PCM: 
  - 动态范围: 192 dB → 96 dB
  - 对语音来说完全足够
  - 人耳无法分辨差异

重采样 24000→16000:
  - 频率范围: 12 kHz → 8 kHz
  - 对语音来说足够（语音主要在 300-3400 Hz）
  - 使用高质量重采样算法，失真极小
```

---

## 如果需要播放原始格式

### 方案 1: 修改为支持 Float32（不推荐）

```cpp
// 需要修改 stream_play_frame
switch_frame_t frame = {0};
frame.data = float_data;  // Float32 数据
frame.datalen = samples * sizeof(float);
// ...

// 问题：
// ❌ FreeSWITCH 不支持 Float32 格式
// ❌ 需要修改 FreeSWITCH 核心代码
```

### 方案 2: 客户端直接发送 16-bit PCM（推荐）

```json
{
  "type": "streamAudio",
  "data": {
    "audioDataType": "raw",
    "sampleRate": 16000,
    "audioData": "<base64_encoded_16bit_pcm>"
  }
}
```

**优点**：
- ✅ 无需 Float32 → 16-bit 转换
- ✅ 减少服务器 CPU 使用
- ✅ 减少网络传输（16-bit 比 Float32 小 50%）

---

## 总结

### 当前实现

**流式播放使用的是：转换之后的语音流**

```
Float32 (原始) 
    → 16-bit PCM (转换后)
    → 16-bit PCM (重采样后)
    → 播放缓冲区
    → 通话中
```

### 转换的必要性

1. ✅ **FreeSWITCH 要求**：必须是 16-bit PCM
2. ✅ **采样率匹配**：必须匹配通话采样率
3. ✅ **性能优化**：减少内存和 CPU 使用
4. ✅ **音质保证**：转换过程音质损失极小

### 优化建议

如果想减少服务器负载：
- 客户端直接发送 16-bit PCM
- 客户端发送通话采样率的音频（如 16000Hz）
- 这样服务器只需要写入缓冲区，无需任何转换

---

## 代码位置总结

| 步骤 | 位置 | 输入 | 输出 |
|------|------|------|------|
| **Float32 → 16-bit** | `audio_streamer_glue.cpp:340-355` | Float32, 24000Hz | 16-bit PCM, 24000Hz |
| **重采样** | `audio_streamer_glue.cpp:372-390` | 16-bit PCM, 24000Hz | 16-bit PCM, 16000Hz |
| **写入缓冲区** | `audio_streamer_glue.cpp:397-402` | 16-bit PCM, 16000Hz | 播放缓冲区 |
| **播放** | `audio_streamer_glue.cpp:stream_play_frame()` | 播放缓冲区 | 通话中 |

所有转换都在接收音频时完成，播放时直接使用转换后的数据。
