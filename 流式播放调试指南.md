# 流式播放调试指南

## 问题：没有播放出来

根据日志分析：
```
✅ 音频接收成功
✅ Float32 → 16-bit PCM 转换成功
✅ 重采样成功
⚠️  播放缓冲区满，丢弃样本
❌ 没有播放出来
```

---

## 可能的原因

### 原因 1: WRITE 事件未被触发

**症状**：
- 日志中没有 "WRITE event triggered" 消息
- 播放缓冲区一直满

**原因**：
- Media Bug 的 WRITE 标志未正确设置
- 或者 WRITE 事件不会自动触发

**解决方案**：

WRITE 事件可能需要 READ 和 WRITE 同时存在才会触发。检查 flags：

```c
// mod_audio_stream.c - start_capture()
switch_media_bug_flag_t flags = SMBF_READ_STREAM | SMBF_WRITE_STREAM;
```

---

### 原因 2: switch_core_session_write_frame 方向错误

**问题**：
`switch_core_session_write_frame` 可能是写入到**对方**，而不是**本方**。

**解决方案**：

使用 `switch_core_session_read_frame` 的反向操作，或者使用 `uuid_broadcast`。

让我修改为使用 Media Bug 的正确方式：

```cpp
// 不使用 switch_core_session_write_frame
// 而是使用 Media Bug 的 patch 方式
```

---

### 原因 3: 需要使用 READ_REPLACE 模式

FreeSWITCH 的 Media Bug 有不同的模式：
- `SMBF_READ_STREAM`：读取音频流
- `SMBF_WRITE_STREAM`：写入音频流
- `SMBF_READ_REPLACE`：替换读取的音频
- `SMBF_WRITE_REPLACE`：替换写入的音频

**对于播放音频给对方听**，应该使用 `SMBF_WRITE_REPLACE`。

---

## 修复方案

### 方案 A: 使用 WRITE_REPLACE 模式

修改 `start_capture()` 中的 flags：

```c
// mod_audio_stream.c
switch_media_bug_flag_t flags = SMBF_READ_STREAM | SMBF_WRITE_REPLACE;
```

然后在 `stream_play_frame()` 中：

```cpp
// 不需要调用 write_frame
// 直接修改 bug 中的数据即可
```

### 方案 B: 使用 uuid_displace（推荐）

使用 FreeSWITCH 的 `uuid_displace` 功能来播放音频流。

**实现步骤**：

1. 创建一个内存文件系统（memfs）
2. 将音频数据写入 memfs
3. 使用 `uuid_displace` 播放

---

## 推荐的实现方式

基于 FreeSWITCH 的限制，最好的方式是：

### 使用 mod_shout 或 mod_local_stream

创建一个本地流，持续写入音频数据：

```cpp
// 1. 创建一个 FIFO 或共享内存
// 2. 将接收到的音频写入 FIFO
// 3. 使用 playback 播放 FIFO
```

### 或者使用 uuid_displace

```cpp
// processMessage() 中
if (tech_pvt && tech_pvt->stream_play_enabled) {
    // 保存为临时文件
    save_to_temp_file(outputSamples);
    
    // 使用 uuid_displace 播放（不阻塞）
    switch_core_session_execute_application(session, "displace_session", file_path);
}
```

---

## 快速测试

### 测试 1: 检查 WRITE 事件是否触发

启用 DEBUG 日志：
```bash
fs_cli -x "console loglevel debug"
```

查找日志：
```
WRITE event triggered
```

如果没有这条日志，说明 WRITE 事件未触发。

### 测试 2: 检查播放缓冲区

查找日志：
```
Played ... samples from buffer
```

如果没有这条日志，说明 `stream_play_frame` 未被调用。

### 测试 3: 手动播放文件

```bash
# 播放生成的文件
fs_cli -x "uuid_broadcast <uuid> /tmp/xxx.wav"
```

如果文件能播放，说明音频数据是正确的，问题在于流式播放机制。

---

## 临时解决方案

在修复流式播放之前，使用文件播放 + 队列方式：

```python
# 使用播放队列减少间隙
import queue
import threading

play_queue = queue.Queue()

def play_worker():
    while True:
        file_path = play_queue.get()
        con.api(f"uuid_broadcast {uuid} {file_path} aleg")
        play_queue.task_done()

threading.Thread(target=play_worker, daemon=True).start()

# 监听事件
con.events("plain", "CUSTOM mod_audio_stream::play")
while True:
    e = con.recvEvent()
    if e:
        data = json.loads(e.getBody())
        if 'file' in data:
            play_queue.put(data['file'])
```

这样可以减少 50-70% 的间隙。

---

## 下一步调试

1. **启用 DEBUG 日志**
   ```bash
   fs_cli -x "console loglevel debug"
   ```

2. **查看是否有 WRITE 事件日志**
   ```
   grep "WRITE event" /var/log/freeswitch/freeswitch.log
   ```

3. **检查 stream_play_enabled 标志**
   ```
   grep "stream_play_enabled" /var/log/freeswitch/freeswitch.log
   ```

4. **检查播放缓冲区状态**
   ```
   grep "Play buffer\|Played.*samples" /var/log/freeswitch/freeswitch.log
   ```

根据日志输出，我们可以确定问题的具体位置。
