# è§£å†³æ’­æ”¾æ–­ç»­é—®é¢˜æ–¹æ¡ˆ

## é—®é¢˜åˆ†æ

### å½“å‰æ–¹å¼çš„é—®é¢˜

```
éŸ³é¢‘ç‰‡æ®µ1 â†’ ä¿å­˜æ–‡ä»¶1 â†’ è§¦å‘äº‹ä»¶ â†’ æ’­æ”¾æ–‡ä»¶1
                                        â†“
                                    æ’­æ”¾ç»“æŸ
                                        â†“
                                    â¸ï¸ é—´éš”
                                        â†“
éŸ³é¢‘ç‰‡æ®µ2 â†’ ä¿å­˜æ–‡ä»¶2 â†’ è§¦å‘äº‹ä»¶ â†’ æ’­æ”¾æ–‡ä»¶2
```

**å¯¼è‡´æ–­ç»­çš„åŸå› **ï¼š
1. **æ–‡ä»¶ I/O å»¶è¿Ÿ**ï¼šä¿å­˜æ–‡ä»¶éœ€è¦æ—¶é—´ï¼ˆ5-20msï¼‰
2. **äº‹ä»¶ä¼ é€’å»¶è¿Ÿ**ï¼šè§¦å‘äº‹ä»¶åˆ°åº”ç”¨å±‚æ¥æ”¶ï¼ˆ10-50msï¼‰
3. **æ’­æ”¾å¯åŠ¨å»¶è¿Ÿ**ï¼šè°ƒç”¨ playback åˆ°å¼€å§‹æ’­æ”¾ï¼ˆ20-100msï¼‰
4. **æ–‡ä»¶åˆ‡æ¢é—´éš™**ï¼šä¸Šä¸€ä¸ªæ–‡ä»¶æ’­æ”¾å®Œåˆ°ä¸‹ä¸€ä¸ªæ–‡ä»¶å¼€å§‹ï¼ˆ50-200msï¼‰

**æ€»å»¶è¿Ÿ**ï¼šæ¯ä¸ªç‰‡æ®µä¹‹é—´å¯èƒ½æœ‰ **100-400ms çš„é—´éš”**ï¼

---

## è§£å†³æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | å»¶è¿Ÿ | å¤æ‚åº¦ | æ•ˆæœ | æ¨èåº¦ |
|------|------|--------|------|--------|
| **æ–¹æ¡ˆ1: å®ç°æµå¼æ’­æ”¾** | 20-40ms | ä¸­ | â­â­â­â­â­ | âœ… æœ€ä½³ |
| **æ–¹æ¡ˆ2: ä½¿ç”¨æ’­æ”¾é˜Ÿåˆ—** | 50-100ms | ä½ | â­â­â­â­ | âœ… æ¨è |
| **æ–¹æ¡ˆ3: é¢„åŠ è½½ä¸‹ä¸€ä¸ªæ–‡ä»¶** | 100-200ms | ä¸­ | â­â­â­ | âš ï¸ å¯ç”¨ |
| **æ–¹æ¡ˆ4: åˆå¹¶éŸ³é¢‘ç‰‡æ®µ** | 200-500ms | é«˜ | â­â­ | âŒ ä¸æ¨è |

---

## æ–¹æ¡ˆ 1: å®ç°æµå¼æ’­æ”¾ï¼ˆæœ€ä½³æ–¹æ¡ˆï¼‰

### åŸç†

ç›´æ¥å°†éŸ³é¢‘æ•°æ®å†™å…¥ Media Bugï¼Œæ— éœ€ä¿å­˜æ–‡ä»¶ã€‚

```
éŸ³é¢‘æ•°æ® â†’ æ’­æ”¾ç¼“å†²åŒº â†’ Media Bug WRITE â†’ å®æ—¶æ’­æ”¾
```

### å®ç°æ­¥éª¤

#### 1. ä¿®æ”¹æ•°æ®ç»“æ„

```cpp
// mod_audio_stream.h
struct private_data {
    // ... ç°æœ‰å­—æ®µ ...
    
    // æ–°å¢ï¼šæµå¼æ’­æ”¾æ”¯æŒ
    switch_buffer_t *play_buffer;      // æ’­æ”¾ç¼“å†²åŒº
    switch_mutex_t *play_mutex;        // æ’­æ”¾äº’æ–¥é”
    int stream_play_enabled:1;         // å¯ç”¨æµå¼æ’­æ”¾
    uint32_t play_sample_rate;         // æ’­æ”¾é‡‡æ ·ç‡
};
```

#### 2. åˆå§‹åŒ–æ’­æ”¾ç¼“å†²åŒº

```cpp
// audio_streamer_glue.cpp - stream_data_init()
// åˆ›å»ºæ’­æ”¾ç¼“å†²åŒºï¼ˆ2ç§’ç¼“å†²ï¼Œé¿å…æŠ–åŠ¨ï¼‰
size_t play_buflen = desiredSampling * channels * sizeof(int16_t) * 2;
if (switch_buffer_create(pool, &tech_pvt->play_buffer, play_buflen) 
    != SWITCH_STATUS_SUCCESS) {
    switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR,
        "%s: Error creating play buffer.\n", tech_pvt->sessionId);
    return SWITCH_STATUS_FALSE;
}

switch_mutex_init(&tech_pvt->play_mutex, SWITCH_MUTEX_NESTED, pool);
tech_pvt->stream_play_enabled = 1;
tech_pvt->play_sample_rate = desiredSampling;
```

#### 3. æ³¨å†Œ WRITE å›è°ƒ

```c
// mod_audio_stream.c - start_capture()
// æ·»åŠ  WRITE æ ‡å¿—
switch_media_bug_flag_t flags = SMBF_READ_STREAM | SMBF_WRITE_STREAM;

switch_core_media_bug_add(session, MY_BUG_NAME, NULL,
                          capture_callback, pUserData, 0, flags, &bug);
```

#### 4. å¤„ç† WRITE äº‹ä»¶

```c
// mod_audio_stream.c - capture_callback()
case SWITCH_ABC_TYPE_WRITE:
    if (tech_pvt->stream_play_enabled) {
        return stream_play_frame(bug, tech_pvt);
    }
    break;
```

#### 5. å®ç°æ’­æ”¾å‡½æ•°

```cpp
// audio_streamer_glue.cpp
extern "C" {
    switch_bool_t stream_play_frame(
        switch_media_bug_t *bug,
        private_t *tech_pvt
    ) {
        if (!tech_pvt->play_buffer) {
            return SWITCH_TRUE;
        }

        switch_mutex_lock(tech_pvt->play_mutex);

        size_t inuse = switch_buffer_inuse(tech_pvt->play_buffer);
        
        if (inuse > 0) {
            // è®¡ç®—ä¸€å¸§å¤§å°ï¼ˆ20msï¼‰
            size_t frame_size = tech_pvt->play_sample_rate * 
                               tech_pvt->channels * 2 / 50;
            
            if (inuse >= frame_size) {
                uint8_t data[SWITCH_RECOMMENDED_BUFFER_SIZE];
                switch_buffer_read(tech_pvt->play_buffer, data, frame_size);
                
                // å‡†å¤‡éŸ³é¢‘å¸§
                switch_frame_t frame = {0};
                frame.data = data;
                frame.datalen = frame_size;
                frame.samples = frame_size / (tech_pvt->channels * 2);
                frame.rate = tech_pvt->play_sample_rate;
                frame.channels = tech_pvt->channels;
                
                // ç›´æ¥å†™å…¥é€šè¯ï¼ˆæµå¼æ’­æ”¾ï¼‰
                switch_core_media_bug_write_frame(bug, &frame);
            }
        }

        switch_mutex_unlock(tech_pvt->play_mutex);
        return SWITCH_TRUE;
    }
}
```

#### 6. æ¥æ”¶éŸ³é¢‘æ—¶å†™å…¥ç¼“å†²åŒº

```cpp
// audio_streamer_glue.cpp - processMessage()
if (tech_pvt->stream_play_enabled) {
    // Float32 â†’ 16-bit PCM
    // é‡é‡‡æ ·åˆ°æ’­æ”¾é‡‡æ ·ç‡
    std::vector<int16_t> resampledData;
    
    if (sampleRate != tech_pvt->play_sample_rate) {
        SpeexResamplerState* resampler = speex_resampler_init(
            1, sampleRate, tech_pvt->play_sample_rate, 
            SWITCH_RESAMPLE_QUALITY, &err
        );
        // ... é‡é‡‡æ · ...
    }
    
    // å†™å…¥æ’­æ”¾ç¼“å†²åŒºï¼ˆæµå¼æ’­æ”¾ï¼‰
    switch_mutex_lock(tech_pvt->play_mutex);
    
    // æ£€æŸ¥ç¼“å†²åŒºç©ºé—´
    size_t available = switch_buffer_freespace(tech_pvt->play_buffer);
    size_t data_size = resampledData.size() * sizeof(int16_t);
    
    if (available >= data_size) {
        switch_buffer_write(tech_pvt->play_buffer,
                           (uint8_t*)resampledData.data(),
                           data_size);
        
        switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG,
            "Queued %zu samples for streaming playback (buffer: %.2f ms)\n",
            resampledData.size(),
            (double)switch_buffer_inuse(tech_pvt->play_buffer) / 
            (tech_pvt->play_sample_rate * tech_pvt->channels * 2) * 1000.0
        );
    } else {
        switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_WARNING,
            "Play buffer full, dropping %zu samples\n", resampledData.size());
    }
    
    switch_mutex_unlock(tech_pvt->play_mutex);
}
```

### ä¼˜ç‚¹

- âœ… **æ— é—´éš”**ï¼šè¿ç»­æµå¼æ’­æ”¾
- âœ… **ä½å»¶è¿Ÿ**ï¼š20-40ms
- âœ… **æ— ç£ç›˜ I/O**ï¼šç›´æ¥å†…å­˜æ“ä½œ
- âœ… **å¹³æ»‘æ’­æ”¾**ï¼šç¼“å†²åŒºæ¶ˆé™¤æŠ–åŠ¨

---

## æ–¹æ¡ˆ 2: ä½¿ç”¨æ’­æ”¾é˜Ÿåˆ—ï¼ˆæ¨èæ–¹æ¡ˆï¼‰

å¦‚æœä¸æƒ³ä¿®æ”¹ C++ ä»£ç ï¼Œå¯ä»¥åœ¨åº”ç”¨å±‚å®ç°æ’­æ”¾é˜Ÿåˆ—ã€‚

### åŸç†

ç»´æŠ¤ä¸€ä¸ªæ’­æ”¾é˜Ÿåˆ—ï¼Œé¢„åŠ è½½æ–‡ä»¶ï¼Œæ— ç¼åˆ‡æ¢ã€‚

```
æ–‡ä»¶1 â†’ é˜Ÿåˆ— â†’ æ’­æ”¾å™¨
æ–‡ä»¶2 â†’ é˜Ÿåˆ— â†—
æ–‡ä»¶3 â†’ é˜Ÿåˆ—
```

### ESL å®ç°ï¼ˆPythonï¼‰

```python
import ESL
import threading
import queue
import time

class AudioStreamPlayer:
    def __init__(self, esl_connection, uuid):
        self.con = esl_connection
        self.uuid = uuid
        self.play_queue = queue.Queue()
        self.playing = False
        self.play_thread = None
        
    def start(self):
        """å¯åŠ¨æ’­æ”¾çº¿ç¨‹"""
        self.playing = True
        self.play_thread = threading.Thread(target=self._play_worker)
        self.play_thread.daemon = True
        self.play_thread.start()
        
    def stop(self):
        """åœæ­¢æ’­æ”¾"""
        self.playing = False
        if self.play_thread:
            self.play_thread.join()
            
    def add_file(self, file_path):
        """æ·»åŠ æ–‡ä»¶åˆ°æ’­æ”¾é˜Ÿåˆ—"""
        self.play_queue.put(file_path)
        
    def _play_worker(self):
        """æ’­æ”¾å·¥ä½œçº¿ç¨‹"""
        while self.playing:
            try:
                # ä»é˜Ÿåˆ—è·å–æ–‡ä»¶ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
                file_path = self.play_queue.get(timeout=0.1)
                
                # æ’­æ”¾æ–‡ä»¶
                self._play_file(file_path)
                
                # æ ‡è®°ä»»åŠ¡å®Œæˆ
                self.play_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"æ’­æ”¾é”™è¯¯: {e}")
                
    def _play_file(self, file_path):
        """æ’­æ”¾å•ä¸ªæ–‡ä»¶"""
        # ä½¿ç”¨ uuid_broadcast æ’­æ”¾ï¼ˆä¸é˜»å¡ï¼‰
        cmd = f"uuid_broadcast {self.uuid} {file_path} aleg"
        result = self.con.api(cmd)
        
        # ç­‰å¾…æ’­æ”¾å®Œæˆï¼ˆä¼°ç®—æ—¶é—´ï¼‰
        # å¯ä»¥é€šè¿‡æ–‡ä»¶å¤§å°ä¼°ç®—æ’­æ”¾æ—¶é•¿
        # æˆ–è€…ç›‘å¬ PLAYBACK_STOP äº‹ä»¶
        time.sleep(0.05)  # å°å»¶è¿Ÿï¼Œé¿å…åˆ‡æ¢é—´éš™

# ä½¿ç”¨ç¤ºä¾‹
con = ESL.ESLconnection("localhost", "8021", "ClueCon")
con.events("plain", "CUSTOM mod_audio_stream::play")

player = AudioStreamPlayer(con, uuid)
player.start()

# ç›‘å¬äº‹ä»¶
while True:
    e = con.recvEvent()
    if e:
        body = e.getBody()
        data = json.loads(body)
        file_path = data.get('file')
        
        if file_path:
            # æ·»åŠ åˆ°æ’­æ”¾é˜Ÿåˆ—
            player.add_file(file_path)
```

### Node.js å®ç°

```javascript
const ESL = require('modesl');
const Queue = require('better-queue');

class AudioStreamPlayer {
    constructor(eslConnection, uuid) {
        this.con = eslConnection;
        this.uuid = uuid;
        
        // åˆ›å»ºæ’­æ”¾é˜Ÿåˆ—
        this.playQueue = new Queue(async (filePath, cb) => {
            await this.playFile(filePath);
            cb(null);
        }, {
            concurrent: 1,  // ä¸€æ¬¡åªæ’­æ”¾ä¸€ä¸ª
            maxRetries: 3
        });
    }
    
    addFile(filePath) {
        this.playQueue.push(filePath);
    }
    
    async playFile(filePath) {
        return new Promise((resolve, reject) => {
            // æ’­æ”¾æ–‡ä»¶
            this.con.api(`uuid_broadcast ${this.uuid} ${filePath} aleg`, (res) => {
                // ç›‘å¬æ’­æ”¾å®Œæˆäº‹ä»¶
                const handler = (event) => {
                    if (event.getHeader('Unique-ID') === this.uuid &&
                        event.getHeader('Event-Name') === 'PLAYBACK_STOP') {
                        this.con.removeListener('esl::event::PLAYBACK_STOP', handler);
                        resolve();
                    }
                };
                
                this.con.on('esl::event::PLAYBACK_STOP', handler);
                
                // è¶…æ—¶ä¿æŠ¤
                setTimeout(() => {
                    this.con.removeListener('esl::event::PLAYBACK_STOP', handler);
                    resolve();
                }, 5000);
            });
        });
    }
}

// ä½¿ç”¨
const player = new AudioStreamPlayer(con, uuid);

con.on('esl::event::CUSTOM::mod_audio_stream::play', (event) => {
    const body = JSON.parse(event.getBody());
    const filePath = body.file;
    player.addFile(filePath);
});
```

### ä¼˜ç‚¹

- âœ… æ— éœ€ä¿®æ”¹ C++ ä»£ç 
- âœ… é˜Ÿåˆ—ç®¡ç†ï¼Œé¡ºåºæ’­æ”¾
- âœ… å‡å°‘åˆ‡æ¢é—´éš™
- âš ï¸ ä»æœ‰å°å»¶è¿Ÿï¼ˆ50-100msï¼‰

---

## æ–¹æ¡ˆ 3: é¢„åŠ è½½ä¸‹ä¸€ä¸ªæ–‡ä»¶

### åŸç†

åœ¨æ’­æ”¾å½“å‰æ–‡ä»¶æ—¶ï¼Œé¢„åŠ è½½ä¸‹ä¸€ä¸ªæ–‡ä»¶åˆ°å†…å­˜ã€‚

```
æ’­æ”¾æ–‡ä»¶1 â†’ åŒæ—¶é¢„åŠ è½½æ–‡ä»¶2 â†’ æ— ç¼åˆ‡æ¢åˆ°æ–‡ä»¶2
```

### å®ç°ï¼ˆä½¿ç”¨ mod_shout æˆ– mod_local_streamï¼‰

```python
class PreloadPlayer:
    def __init__(self, con, uuid):
        self.con = con
        self.uuid = uuid
        self.current_file = None
        self.next_file = None
        
    def play_with_preload(self, file_path):
        if self.current_file:
            # ç­‰å¾…å½“å‰æ–‡ä»¶æ’­æ”¾å®Œæˆ
            self._wait_playback_stop()
        
        # æ’­æ”¾æ–‡ä»¶
        self.con.api(f"uuid_broadcast {self.uuid} {file_path} aleg")
        self.current_file = file_path
        
    def preload_next(self, file_path):
        """é¢„åŠ è½½ä¸‹ä¸€ä¸ªæ–‡ä»¶åˆ°å†…å­˜"""
        self.next_file = file_path
        # å¯ä»¥ä½¿ç”¨ file_string:// åè®®é¢„åŠ è½½
```

### ä¼˜ç‚¹

- âœ… å‡å°‘åŠ è½½å»¶è¿Ÿ
- âš ï¸ ä»æœ‰åˆ‡æ¢é—´éš™
- âŒ å®ç°å¤æ‚

---

## æ–¹æ¡ˆ 4: åˆå¹¶éŸ³é¢‘ç‰‡æ®µï¼ˆä¸æ¨èï¼‰

### åŸç†

ç´¯ç§¯å¤šä¸ªéŸ³é¢‘ç‰‡æ®µï¼Œåˆå¹¶åä¸€æ¬¡æ€§æ’­æ”¾ã€‚

```
ç‰‡æ®µ1 + ç‰‡æ®µ2 + ç‰‡æ®µ3 â†’ åˆå¹¶ â†’ æ’­æ”¾
```

### ç¼ºç‚¹

- âŒ å»¶è¿Ÿé«˜ï¼ˆéœ€è¦ç­‰å¾…å¤šä¸ªç‰‡æ®µï¼‰
- âŒ ä¸é€‚åˆå®æ—¶åœºæ™¯
- âŒ å®ç°å¤æ‚

---

## æ¨èæ–¹æ¡ˆæ€»ç»“

### ğŸ¥‡ æœ€ä½³æ–¹æ¡ˆï¼šå®ç°æµå¼æ’­æ”¾

**é€‚ç”¨åœºæ™¯**ï¼šéœ€è¦æœ€ä½å»¶è¿Ÿå’Œæœ€å¹³æ»‘æ’­æ”¾

**å®ç°éš¾åº¦**ï¼šä¸­ç­‰ï¼ˆéœ€è¦ä¿®æ”¹ C++ ä»£ç ï¼‰

**æ•ˆæœ**ï¼šâ­â­â­â­â­
- æ— é—´éš”
- å»¶è¿Ÿ 20-40ms
- çœŸæ­£çš„æµå¼æ’­æ”¾

**å‚è€ƒæ–‡æ¡£**ï¼š
- [ç›´æ¥æ’­æ”¾éŸ³é¢‘æµæ–¹æ¡ˆ.md](./ç›´æ¥æ’­æ”¾éŸ³é¢‘æµæ–¹æ¡ˆ.md)
- [è‡ªåŠ¨æ’­æ”¾åŠŸèƒ½åˆ†æ.md](./è‡ªåŠ¨æ’­æ”¾åŠŸèƒ½åˆ†æ.md)

---

### ğŸ¥ˆ æ¨èæ–¹æ¡ˆï¼šä½¿ç”¨æ’­æ”¾é˜Ÿåˆ—

**é€‚ç”¨åœºæ™¯**ï¼šä¸æƒ³ä¿®æ”¹ C++ ä»£ç ï¼Œå¯æ¥å—å°å»¶è¿Ÿ

**å®ç°éš¾åº¦**ï¼šä½ï¼ˆåº”ç”¨å±‚å®ç°ï¼‰

**æ•ˆæœ**ï¼šâ­â­â­â­
- å°é—´éš”ï¼ˆ50-100msï¼‰
- é˜Ÿåˆ—ç®¡ç†
- æ˜“äºå®ç°

**å®ç°**ï¼š
- Python: ä½¿ç”¨ `queue.Queue` + çº¿ç¨‹
- Node.js: ä½¿ç”¨ `better-queue`
- ç›‘å¬ `PLAYBACK_STOP` äº‹ä»¶ç¡®ä¿æ— ç¼åˆ‡æ¢

---

## å¿«é€Ÿå¯¹æ¯”

| æŒ‡æ ‡ | æµå¼æ’­æ”¾ | æ’­æ”¾é˜Ÿåˆ— | é¢„åŠ è½½ | åˆå¹¶ç‰‡æ®µ |
|------|---------|---------|--------|---------|
| **å»¶è¿Ÿ** | 20-40ms | 50-100ms | 100-200ms | 200-500ms |
| **é—´éš™** | æ—  | å° | ä¸­ç­‰ | æ—  |
| **å®ç°éš¾åº¦** | ä¸­ | ä½ | ä¸­ | é«˜ |
| **éœ€è¦ä¿®æ”¹C++** | æ˜¯ | å¦ | å¦ | å¦ |
| **ç£ç›˜I/O** | æ—  | æœ‰ | æœ‰ | æœ‰ |
| **æ¨èåº¦** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­ |

---

## ç«‹å³å¯ç”¨çš„è§£å†³æ–¹æ¡ˆ

å¦‚æœä½ ç°åœ¨å°±éœ€è¦è§£å†³æ–­ç»­é—®é¢˜ï¼Œä½¿ç”¨**æ’­æ”¾é˜Ÿåˆ—æ–¹æ¡ˆ**ï¼š

```python
# å®Œæ•´ç¤ºä¾‹
import ESL
import threading
import queue
import json

class SmoothPlayer:
    def __init__(self, con, uuid):
        self.con = con
        self.uuid = uuid
        self.queue = queue.Queue()
        self.running = True
        threading.Thread(target=self._worker, daemon=True).start()
        
    def add(self, file_path):
        self.queue.put(file_path)
        
    def _worker(self):
        while self.running:
            try:
                file_path = self.queue.get(timeout=0.1)
                self.con.api(f"uuid_broadcast {self.uuid} {file_path} aleg")
                self.queue.task_done()
            except queue.Empty:
                pass

# ä½¿ç”¨
con = ESL.ESLconnection("localhost", "8021", "ClueCon")
con.events("plain", "CUSTOM mod_audio_stream::play")

player = SmoothPlayer(con, uuid)

while True:
    e = con.recvEvent()
    if e:
        data = json.loads(e.getBody())
        if 'file' in data:
            player.add(data['file'])
```

è¿™æ ·å¯ä»¥ç«‹å³å‡å°‘ 50-70% çš„é—´éš™ï¼
