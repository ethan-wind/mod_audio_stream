# audio_streamer_glue.cpp 播放逻辑分析

## 结论：**没有实际播放逻辑，只有播放准备逻辑**

`audio_streamer_glue.cpp` **并不包含真正的音频播放逻辑**，它只负责：
1. 接收 WebSocket 服务器发送的音频数据
2. 将音频数据保存为临时文件
3. 触发 `EVENT_PLAY` 事件通知 FreeSWITCH
4. **实际播放由 FreeSWITCH 的其他组件或应用层完成**

---

## 一、播放相关代码位置

### 1.1 核心函数：`processMessage()`

**位置**：`audio_streamer_glue.cpp` 第 189-265 行

**功能**：处理 WebSocket 服务器发送的 `streamAudio` 类型消息

```cpp
switch_bool_t processMessage(switch_core_session_t* session, std::string& message) {
    cJSON* json = cJSON_Parse(message.c_str());
    
    // 检查消息类型是否为 "streamAudio"
    const char* jsType = cJSON_GetObjectCstr(json, "type");
    if(jsType && strcmp(jsType, "streamAudio") == 0) {
        // 处理音频数据...
    }
}
```

---

## 二、播放准备流程详解

### 2.1 完整流程

```
WebSocket 收到消息
    │
    ▼
eventCallback(MESSAGE, message)
    │
    ▼
processMessage(session, message)
    │
    ├─ 解析 JSON
    │
    ▼
检查 type == "streamAudio"
    │
    ├─ 否 ──> 返回 SWITCH_FALSE（触发 EVENT_JSON）
    │
    ├─ 是
    │   │
    │   ▼
    │ 提取 data 对象
    │   │
    │   ├─ audioDataType (raw/wav/mp3/ogg)
    │   ├─ sampleRate (仅 raw 需要)
    │   └─ audioData (Base64 编码)
    │
    ▼
根据 audioDataType 确定文件扩展名
    │
    ├─ raw + 8000Hz  ──> .r8
    ├─ raw + 16000Hz ──> .r16
    ├─ raw + 24000Hz ──> .r24
    ├─ raw + 32000Hz ──> .r32
    ├─ raw + 48000Hz ──> .r48
    ├─ raw + 64000Hz ──> .r64
    ├─ wav           ──> .wav
    ├─ mp3           ──> .mp3
    └─ ogg           ──> .ogg
    │
    ▼
Base64 解码音频数据
    │
    ▼
生成临时文件路径
/tmp/{sessionId}_{counter}.tmp{extension}
    │
    ▼
写入文件
    │
    ├─ std::ofstream fstream(filePath, binary)
    ├─ fstream << rawAudio
    └─ fstream.close()
    │
    ▼
记录文件路径
    │
    └─> m_Files.insert(filePath)
    │
    ▼
构造事件 JSON
    │
    ├─ 移除 audioData 字段（太大）
    ├─ 添加 file 字段（文件路径）
    │
    └─> {
          "audioDataType": "raw",
          "sampleRate": 8000,
          "file": "/tmp/uuid_0.tmp.r8"
        }
    │
    ▼
触发 EVENT_PLAY 事件
    │
    └─> m_notify(session, EVENT_PLAY, jsonString)
        │
        └─> responseHandler() [mod_audio_stream.c]
            │
            └─> switch_event_fire()
                │
                └─> 分发到订阅者（ESL、Dialplan 等）
```

### 2.2 关键代码片段

#### 文件扩展名映射
```cpp
if (0 == strcmp(jsAudioDataType, "raw")) {
    cJSON* jsonSampleRate = cJSON_GetObjectItem(jsonData, "sampleRate");
    sampleRate = jsonSampleRate && jsonSampleRate->valueint ? 
                 jsonSampleRate->valueint : 0;
    
    std::unordered_map<int, const char*> sampleRateMap = {
        {8000, ".r8"},
        {16000, ".r16"},
        {24000, ".r24"},
        {32000, ".r32"},
        {48000, ".r48"},
        {64000, ".r64"}
    };
    
    auto it = sampleRateMap.find(sampleRate);
    fileType = (it != sampleRateMap.end()) ? it->second : "";
}
```

#### Base64 解码与文件保存
```cpp
// Base64 解码
std::string rawAudio;
try {
    rawAudio = base64_decode(jsonAudio->valuestring);
} catch (const std::exception& e) {
    switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), 
                      SWITCH_LOG_ERROR, 
                      "(%s) processMessage - base64 decode error: %s\n",
                      m_sessionId.c_str(), e.what());
    return status;
}

// 生成文件路径
char filePath[256];
switch_snprintf(filePath, 256, "%s%s%s_%d.tmp%s", 
                SWITCH_GLOBAL_dirs.temp_dir,
                SWITCH_PATH_SEPARATOR, 
                m_sessionId.c_str(), 
                m_playFile++,  // 计数器递增
                fileType.c_str());

// 写入文件
std::ofstream fstream(filePath, std::ofstream::binary);
fstream << rawAudio;
fstream.close();

// 记录文件路径（用于后续清理）
m_Files.insert(filePath);
```

#### 触发播放事件
```cpp
if(jsonFile) {
    // 构造事件 JSON（包含文件路径，不包含 audioData）
    char *jsonString = cJSON_PrintUnformatted(jsonData);
    
    // 触发 EVENT_PLAY 事件
    m_notify(session, EVENT_PLAY, jsonString);
    
    // 修改原始消息（用于日志）
    message.assign(jsonString);
    free(jsonString);
    
    status = SWITCH_TRUE;  // 表示已处理
}
```

---

## 三、播放相关的成员变量

### 3.1 AudioStreamer 类成员

```cpp
class AudioStreamer {
private:
    int m_playFile;  // 播放文件计数器，初始化为 0
    std::unordered_set<std::string> m_Files;  // 临时文件集合
    
public:
    // 构造函数中初始化
    AudioStreamer(...) : ..., m_playFile(0) { }
    
    // 清理临时文件
    void deleteFiles() {
        if(m_playFile > 0) {
            for (const auto &fileName: m_Files) {
                remove(fileName.c_str());  // 删除文件
            }
        }
    }
};
```

### 3.2 文件命名规则

**格式**：`{temp_dir}/{sessionId}_{counter}.tmp{extension}`

**示例**：
- `/tmp/12345-uuid_0.tmp.r8`  （第 1 个文件，8kHz raw）
- `/tmp/12345-uuid_1.tmp.wav` （第 2 个文件，WAV）
- `/tmp/12345-uuid_2.tmp.mp3` （第 3 个文件，MP3）

**计数器**：`m_playFile++` 每次递增，确保文件名唯一

---

## 四、资源清理机制

### 4.1 清理时机

临时文件在以下情况被删除：

```cpp
// stream_session_cleanup() 函数中
auto* audioStreamer = (AudioStreamer *) tech_pvt->pAudioStreamer;
if(audioStreamer) {
    audioStreamer->deleteFiles();  // 删除所有临时文件
    if (text) audioStreamer->writeText(text);
    finish(tech_pvt);
}
```

**触发场景**：
1. 调用 `uuid_audio_stream stop` 命令
2. 通话挂断（SWITCH_ABC_TYPE_CLOSE）
3. 连接错误导致清理

### 4.2 清理实现

```cpp
void deleteFiles() {
    if(m_playFile > 0) {  // 有文件才清理
        for (const auto &fileName: m_Files) {
            remove(fileName.c_str());  // 系统调用删除文件
        }
    }
}
```

---

## 五、实际播放由谁完成？

### 5.1 播放责任分离

`mod_audio_stream` **不负责播放**，它只是：
1. 准备音频文件
2. 触发事件通知

**实际播放由以下方式实现**：

#### 方式 1：ESL 脚本监听事件并播放

```python
import ESL

con = ESL.ESLconnection("localhost", "8021", "ClueCon")
con.events("plain", "CUSTOM mod_audio_stream::play")

while True:
    e = con.recvEvent()
    if e:
        body = e.getBody()
        data = json.loads(body)
        file_path = data['file']
        uuid = e.getHeader("Unique-ID")
        
        # 使用 FreeSWITCH 播放文件
        con.api("uuid_broadcast", f"{uuid} {file_path} both")
```

#### 方式 2：Dialplan 中监听事件

```xml
<extension name="handle_play_event">
  <condition field="${Event-Subclass}" expression="mod_audio_stream::play">
    <!-- 提取文件路径 -->
    <action application="set" data="play_file=${event_body_file}"/>
    <!-- 播放文件 -->
    <action application="playback" data="${play_file}"/>
  </condition>
</extension>
```

#### 方式 3：使用 uuid_broadcast 命令

```bash
# 在事件处理程序中
fs_cli> uuid_broadcast <uuid> /tmp/uuid_0.tmp.r8 both
```

### 5.2 支持的音频格式

FreeSWITCH 原生支持以下格式：

| 格式 | 扩展名 | 说明 |
|------|--------|------|
| Raw PCM | .r8, .r16, .r24, .r32, .r48, .r64 | 原始 PCM，数字表示采样率（kHz） |
| WAV | .wav | 标准 WAV 文件 |
| MP3 | .mp3 | 需要 mod_shout 模块 |
| OGG | .ogg | 需要 mod_ogg 模块 |

---

## 六、为什么这样设计？

### 6.1 职责分离原则

```
┌─────────────────────────────────────┐
│  mod_audio_stream                   │
│  职责：音频流传输与接收              │
│  - 发送音频到 WebSocket              │
│  - 接收音频并保存文件                │
│  - 触发事件通知                      │
└─────────────────────────────────────┘
                │
                │ EVENT_PLAY
                ▼
┌─────────────────────────────────────┐
│  应用层（ESL/Dialplan）              │
│  职责：业务逻辑与播放控制            │
│  - 决定是否播放                      │
│  - 决定何时播放                      │
│  - 决定如何播放（打断、混音等）      │
└─────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────┐
│  FreeSWITCH Core                    │
│  职责：实际音频播放                  │
│  - playback 应用                     │
│  - uuid_broadcast API                │
│  - 音频混音与编码                    │
└─────────────────────────────────────┘
```

### 6.2 设计优势

1. **灵活性**：应用层可以决定播放策略
   - 立即播放 vs 队列播放
   - 打断当前播放 vs 等待播放完成
   - 播放到主叫 vs 被叫 vs 双方

2. **解耦**：模块不依赖 FreeSWITCH 的播放 API
   - 更容易测试
   - 更容易维护
   - 更容易扩展

3. **可控性**：应用层可以实现复杂逻辑
   - 播放前验证文件
   - 播放前转码
   - 播放后删除（或保留）
   - 播放失败重试

---

## 七、完整示例：实现自动播放

### 7.1 ESL 脚本实现

```python
#!/usr/bin/env python3
import ESL
import json
import time

class AudioStreamPlayer:
    def __init__(self):
        self.con = ESL.ESLconnection("localhost", "8021", "ClueCon")
        if not self.con.connected():
            raise Exception("Failed to connect to FreeSWITCH")
        
        # 订阅播放事件
        self.con.events("plain", "CUSTOM mod_audio_stream::play")
        print("Listening for play events...")
    
    def run(self):
        while True:
            e = self.con.recvEvent()
            if e:
                self.handle_play_event(e)
    
    def handle_play_event(self, event):
        # 获取会话 UUID
        uuid = event.getHeader("Unique-ID")
        
        # 解析事件 Body
        body = event.getBody()
        try:
            data = json.loads(body)
            file_path = data.get('file')
            audio_type = data.get('audioDataType')
            sample_rate = data.get('sampleRate')
            
            print(f"[{uuid}] Received audio: {audio_type}, {sample_rate}Hz")
            print(f"[{uuid}] File: {file_path}")
            
            # 播放音频（both = 主叫和被叫都能听到）
            result = self.con.api("uuid_broadcast", f"{uuid} {file_path} both")
            print(f"[{uuid}] Playback result: {result.getBody()}")
            
        except json.JSONDecodeError as e:
            print(f"Failed to parse event body: {e}")
        except Exception as e:
            print(f"Error handling play event: {e}")

if __name__ == "__main__":
    player = AudioStreamPlayer()
    player.run()
```

### 7.2 运行效果

```
Listening for play events...
[12345-uuid] Received audio: raw, 8000Hz
[12345-uuid] File: /tmp/12345-uuid_0.tmp.r8
[12345-uuid] Playback result: +OK
[12345-uuid] Received audio: raw, 8000Hz
[12345-uuid] File: /tmp/12345-uuid_1.tmp.r8
[12345-uuid] Playback result: +OK
```

---

## 八、总结

### 8.1 核心发现

| 项目 | 说明 |
|------|------|
| **是否有播放逻辑** | ❌ 没有 |
| **有什么逻辑** | ✅ 音频接收、Base64 解码、文件保存、事件触发 |
| **谁负责播放** | FreeSWITCH Core + 应用层（ESL/Dialplan） |
| **文件格式支持** | raw (.r8/.r16 等), wav, mp3, ogg |
| **文件清理** | 会话结束时自动删除 |

### 8.2 关键代码位置

```
audio_streamer_glue.cpp
├─ processMessage()        [189-265 行]  # 处理 streamAudio 消息
├─ deleteFiles()           [289-294 行]  # 清理临时文件
└─ m_playFile, m_Files     [302-304 行]  # 播放相关成员变量
```

### 8.3 工作流程

```
WebSocket 服务器
    │
    │ 发送 JSON
    │ {
    │   "type": "streamAudio",
    │   "data": {
    │     "audioDataType": "raw",
    │     "sampleRate": 8000,
    │     "audioData": "base64..."
    │   }
    │ }
    │
    ▼
mod_audio_stream
    │
    ├─ Base64 解码
    ├─ 保存到 /tmp/uuid_0.tmp.r8
    ├─ 触发 EVENT_PLAY 事件
    │
    ▼
应用层（ESL/Dialplan）
    │
    ├─ 监听 EVENT_PLAY
    ├─ 提取文件路径
    ├─ 调用 uuid_broadcast
    │
    ▼
FreeSWITCH Core
    │
    └─ 实际播放音频
```

---

**结论**：`audio_streamer_glue.cpp` 是一个"播放准备器"而非"播放器"，它为播放做好准备，但不执行播放动作。这种设计提供了最大的灵活性，让应用层可以根据业务需求自由控制播放行为。
