# FreeSWITCH 直接播放音频流方案

## 当前实现 vs 直接播放

### 当前实现（保存文件方式）

```
客户端上传 Float32 音频
    ↓
Base64 解码
    ↓
Float32 → 16-bit PCM
    ↓
重采样 24000Hz → 8000Hz
    ↓
转换为 G.711 A-law
    ↓
保存为临时 WAV 文件
    ↓
触发 EVENT_PLAY 事件
    ↓
应用层调用 playback 播放文件
```

**缺点**：
- 需要磁盘 I/O
- 延迟较高
- 需要管理临时文件
- 不适合实时流式播放

---

### 直接播放方案（流式播放）

```
客户端上传 Float32 音频
    ↓
Base64 解码
    ↓
Float32 → 16-bit PCM
    ↓
重采样到通话采样率
    ↓
直接写入 Media Bug
    ↓
实时播放到通话中
```

**优点**：
- 无磁盘 I/O
- 延迟极低
- 无需文件管理
- 真正的流式播放

---

## 实现方案

### 方案 1: 使用 Media Bug 写入（推荐）

通过 `switch_core_media_bug_write_frame()` 直接将音频写入通话。

#### 修改数据结构

```cpp
// mod_audio_stream.h
struct private_data {
    // ... 现有字段 ...
    
    // 新增：用于存储待播放的音频数据
    switch_buffer_t *play_buffer;      // 播放缓冲区
    switch_mutex_t *play_mutex;        // 播放缓冲区互斥锁
    int stream_play_enabled:1;         // 是否启用流式播放
};
```

#### 修改 capture_callback

```c
// mod_audio_stream.c
static switch_bool_t capture_callback(
    switch_media_bug_t *bug,
    void *user_data,
    switch_abc_type_t type
) {
    switch_core_session_t *session = switch_core_media_bug_get_session(bug);
    private_t *tech_pvt = (private_t *)user_data;

    switch (type) {
        case SWITCH_ABC_TYPE_INIT:
            break;

        case SWITCH_ABC_TYPE_READ:
            // 下行：FreeSWITCH → 客户端
            if (tech_pvt->close_requested) {
                return SWITCH_FALSE;
            }
            return stream_frame(bug);
            break;

        case SWITCH_ABC_TYPE_WRITE:
            // 上行：客户端 → FreeSWITCH（新增）
            if (tech_pvt->stream_play_enabled) {
                return stream_play_frame(bug, tech_pvt);
            }
            break;

        case SWITCH_ABC_TYPE_CLOSE:
            stream_session_cleanup(session, NULL, channelIsClosing);
            break;
    }

    return SWITCH_TRUE;
}
```

#### 实现 stream_play_frame

```c
// audio_streamer_glue.cpp
switch_bool_t stream_play_frame(
    switch_media_bug_t *bug,
    private_t *tech_pvt
) {
    if (!tech_pvt->play_buffer) {
        return SWITCH_TRUE;
    }

    switch_mutex_lock(tech_pvt->play_mutex);

    // 检查播放缓冲区是否有数据
    size_t inuse = switch_buffer_inuse(tech_pvt->play_buffer);
    
    if (inuse > 0) {
        // 准备音频帧
        switch_frame_t frame = {0};
        uint8_t data[SWITCH_RECOMMENDED_BUFFER_SIZE];
        
        // 计算一帧的大小（20ms）
        size_t frame_size = tech_pvt->sampling * tech_pvt->channels * 2 / 50;  // 20ms
        
        if (inuse >= frame_size) {
            // 从缓冲区读取一帧数据
            switch_buffer_read(tech_pvt->play_buffer, data, frame_size);
            
            // 设置帧参数
            frame.data = data;
            frame.datalen = frame_size;
            frame.samples = frame_size / (tech_pvt->channels * 2);
            frame.rate = tech_pvt->sampling;
            frame.channels = tech_pvt->channels;
            
            // 写入 Media Bug（播放到通话中）
            switch_core_media_bug_write_frame(bug, &frame);
        }
    }

    switch_mutex_unlock(tech_pvt->play_mutex);
    return SWITCH_TRUE;
}
```

#### 修改 processMessage（接收音频）

```cpp
// audio_streamer_glue.cpp - processMessage()
if (jsAudioDataType && 0 == strcmp(jsAudioDataType, "raw") && sampleRate > 0) {
    // ... Float32 转 16-bit PCM ...
    // ... 重采样到通话采样率 ...
    
    // 获取 tech_pvt
    auto *bug = get_media_bug(session);
    if (bug) {
        auto* tech_pvt = (private_t*) switch_core_media_bug_get_user_data(bug);
        
        if (tech_pvt && tech_pvt->stream_play_enabled) {
            // 直接写入播放缓冲区
            switch_mutex_lock(tech_pvt->play_mutex);
            
            // 重采样到通话采样率（而不是 8000Hz）
            std::vector<int16_t> resampledData;
            if (sampleRate != tech_pvt->sampling) {
                // 重采样到通话采样率
                SpeexResamplerState* resampler = speex_resampler_init(
                    1, sampleRate, tech_pvt->sampling, SWITCH_RESAMPLE_QUALITY, &err
                );
                // ... 重采样处理 ...
            }
            
            // 写入播放缓冲区
            switch_buffer_write(
                tech_pvt->play_buffer,
                (uint8_t*)resampledData.data(),
                resampledData.size() * sizeof(int16_t)
            );
            
            switch_mutex_unlock(tech_pvt->play_mutex);
            
            switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_INFO,
                              "(%s) processMessage - queued %zu samples for streaming playback\n",
                              m_sessionId.c_str(), resampledData.size());
        } else {
            // 回退到文件播放方式
            // ... 保存为 WAV 文件 ...
        }
    }
}
```

---

### 方案 2: 使用 switch_core_session_write_frame（备选）

直接向会话写入音频帧。

```cpp
switch_status_t play_audio_stream(
    switch_core_session_t *session,
    int16_t *audio_data,
    size_t samples,
    int sample_rate,
    int channels
) {
    switch_frame_t frame = {0};
    
    frame.data = audio_data;
    frame.datalen = samples * channels * sizeof(int16_t);
    frame.samples = samples;
    frame.rate = sample_rate;
    frame.channels = channels;
    frame.codec = switch_core_session_get_read_codec(session);
    
    return switch_core_session_write_frame(session, &frame, SWITCH_IO_FLAG_NONE, 0);
}
```

---

## 完整实现代码

### 1. 修改头文件

```cpp
// mod_audio_stream.h
struct private_data {
    switch_mutex_t *mutex;
    char sessionId[MAX_SESSION_ID];
    SpeexResamplerState *resampler;
    responseHandler_t responseHandler;
    void *pAudioStreamer;
    char ws_uri[MAX_WS_URI];
    int sampling;
    int channels;
    int audio_paused:1;
    int close_requested:1;
    char initialMetadata[8192];
    switch_buffer_t *sbuffer;
    int rtp_packets;
    
    // 新增：流式播放支持
    switch_buffer_t *play_buffer;      // 播放缓冲区
    switch_mutex_t *play_mutex;        // 播放互斥锁
    int stream_play_enabled:1;         // 启用流式播放
};

// 新增函数声明
switch_bool_t stream_play_frame(switch_media_bug_t *bug, private_t *tech_pvt);
```

### 2. 初始化播放缓冲区

```cpp
// audio_streamer_glue.cpp - stream_data_init()
switch_status_t stream_data_init(...) {
    // ... 现有初始化代码 ...
    
    // 初始化播放缓冲区（1秒的缓冲）
    size_t play_buflen = desiredSampling * channels * sizeof(int16_t);
    if (switch_buffer_create(pool, &tech_pvt->play_buffer, play_buflen) != SWITCH_STATUS_SUCCESS) {
        switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR,
            "%s: Error creating play buffer.\n", tech_pvt->sessionId);
        return SWITCH_STATUS_FALSE;
    }
    
    // 初始化播放互斥锁
    switch_mutex_init(&tech_pvt->play_mutex, SWITCH_MUTEX_NESTED, pool);
    
    // 默认启用流式播放
    tech_pvt->stream_play_enabled = 1;
    
    return SWITCH_STATUS_SUCCESS;
}
```

### 3. 清理资源

```cpp
// audio_streamer_glue.cpp - destroy_tech_pvt()
void destroy_tech_pvt(private_t* tech_pvt) {
    // ... 现有清理代码 ...
    
    if (tech_pvt->play_mutex) {
        switch_mutex_destroy(tech_pvt->play_mutex);
        tech_pvt->play_mutex = nullptr;
    }
    
    if (tech_pvt->play_buffer) {
        switch_buffer_destroy(&tech_pvt->play_buffer);
        tech_pvt->play_buffer = nullptr;
    }
}
```

### 4. 注册 WRITE 回调

```c
// mod_audio_stream.c - start_capture()
// 修改 flags 以包含 WRITE
switch_media_bug_flag_t flags = SMBF_READ_STREAM | SMBF_WRITE_STREAM;

if ((status = switch_core_media_bug_add(
    session,
    MY_BUG_NAME,
    NULL,
    capture_callback,
    pUserData,
    0,
    flags,  // 包含 WRITE
    &bug
)) != SWITCH_STATUS_SUCCESS) {
    return status;
}
```

---

## 使用方式

### 启用流式播放

```javascript
// 启动音频流时启用流式播放
uuid_audio_stream <uuid> start ws://server/path sampling=16000 stream_play=true
```

### 客户端发送音频

```json
{
  "type": "streamAudio",
  "data": {
    "audioDataType": "raw",
    "sampleRate": 24000,
    "audioData": "<base64_float32>",
    "streamPlay": true
  }
}
```

### 禁用流式播放（回退到文件方式）

```json
{
  "type": "streamAudio",
  "data": {
    "audioDataType": "raw",
    "sampleRate": 24000,
    "audioData": "<base64_float32>",
    "streamPlay": false
  }
}
```

---

## 性能对比

| 特性 | 文件播放 | 流式播放 |
|------|---------|---------|
| **延迟** | 50-200ms | 20-40ms |
| **磁盘 I/O** | 需要 | 不需要 |
| **内存使用** | 低 | 中等 |
| **CPU 使用** | 低 | 低 |
| **实时性** | 差 | 优秀 |
| **适用场景** | 预录音频 | 实时语音流 |

---

## 注意事项

### 1. 缓冲区大小

```cpp
// 建议缓冲 0.5-1 秒的音频
size_t play_buflen = sampling * channels * sizeof(int16_t);  // 1秒
```

### 2. 采样率匹配

```cpp
// 必须重采样到通话采样率
if (sampleRate != tech_pvt->sampling) {
    // 重采样到 tech_pvt->sampling（通话采样率）
    // 而不是固定的 8000Hz
}
```

### 3. 缓冲区溢出处理

```cpp
// 检查缓冲区空间
size_t available = switch_buffer_freespace(tech_pvt->play_buffer);
if (available < data_size) {
    // 缓冲区满，丢弃旧数据或等待
    switch_buffer_zero(tech_pvt->play_buffer);
}
```

### 4. 线程安全

```cpp
// 所有播放缓冲区操作都需要加锁
switch_mutex_lock(tech_pvt->play_mutex);
// ... 操作播放缓冲区 ...
switch_mutex_unlock(tech_pvt->play_mutex);
```

---

## 调试技巧

### 查看播放缓冲区状态

```cpp
switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG,
    "Play buffer: inuse=%zu, freespace=%zu\n",
    switch_buffer_inuse(tech_pvt->play_buffer),
    switch_buffer_freespace(tech_pvt->play_buffer)
);
```

### 监控播放延迟

```cpp
// 计算缓冲区中的音频时长
size_t inuse = switch_buffer_inuse(tech_pvt->play_buffer);
size_t samples = inuse / (tech_pvt->channels * sizeof(int16_t));
double duration_ms = (double)samples / tech_pvt->sampling * 1000.0;

switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG,
    "Play buffer duration: %.2f ms\n", duration_ms);
```

---

## 总结

**推荐使用方案 1（Media Bug 写入）**：
- ✅ 真正的流式播放
- ✅ 延迟极低（20-40ms）
- ✅ 无磁盘 I/O
- ✅ 与现有架构集成良好
- ✅ 支持双向音频流

**实现步骤**：
1. 添加播放缓冲区和互斥锁
2. 修改 capture_callback 处理 WRITE 事件
3. 实现 stream_play_frame 函数
4. 修改 processMessage 写入播放缓冲区
5. 更新初始化和清理代码

这样就可以实现真正的实时音频流播放，无需保存临时文件！
