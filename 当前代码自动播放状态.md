# å½“å‰ä»£ç è‡ªåŠ¨æ’­æ”¾çŠ¶æ€

## âŒ ç»“è®ºï¼šå½“å‰ä»£ç **ä¸ä¼š**è‡ªåŠ¨æ’­æ”¾

---

## è¯æ®åˆ†æ

### 1. æ•°æ®ç»“æ„ä¸­æ²¡æœ‰æ’­æ”¾ç¼“å†²åŒº

**æ–‡ä»¶**: `mod_audio_stream.h`

```cpp
struct private_data {
    switch_mutex_t *mutex;
    char sessionId[MAX_SESSION_ID];
    SpeexResamplerState *resampler;
    responseHandler_t responseHandler;
    void *pAudioStreamer;
    char ws_uri[MAX_WS_URI];
    int sampling;
    int channels;
    int audio_paused:1;
    int close_requested:1;
    char initialMetadata[8192];
    switch_buffer_t *sbuffer;        // è¿™æ˜¯ä¸‹è¡Œç¼“å†²åŒºï¼Œä¸æ˜¯æ’­æ”¾ç¼“å†²åŒº
    int rtp_packets;
    // âŒ æ²¡æœ‰ play_buffer
    // âŒ æ²¡æœ‰ play_mutex
    // âŒ æ²¡æœ‰ auto_play_enabled
};
```

**ç¼ºå¤±çš„å­—æ®µ**ï¼š
- `switch_buffer_t *play_buffer` - æ’­æ”¾ç¼“å†²åŒº
- `switch_mutex_t *play_mutex` - æ’­æ”¾äº’æ–¥é”
- `int auto_play_enabled` - è‡ªåŠ¨æ’­æ”¾æ ‡å¿—

---

### 2. capture_callback ä¸å¤„ç† WRITE äº‹ä»¶

**æ–‡ä»¶**: `mod_audio_stream.c`

```c
static switch_bool_t capture_callback(
    switch_media_bug_t *bug,
    void *user_data,
    switch_abc_type_t type
) {
    switch (type) {
        case SWITCH_ABC_TYPE_INIT:
            break;

        case SWITCH_ABC_TYPE_READ:
            // âœ… å¤„ç†ä¸‹è¡Œï¼ˆFreeSWITCH â†’ å®¢æˆ·ç«¯ï¼‰
            return stream_frame(bug);
            break;

        case SWITCH_ABC_TYPE_WRITE:
            // âŒ ä¸å¤„ç†ä¸Šè¡Œæ’­æ”¾
            // âŒ æ²¡æœ‰è°ƒç”¨ stream_play_frame()
        default:
            break;
    }

    return SWITCH_TRUE;
}
```

**é—®é¢˜**ï¼š
- `SWITCH_ABC_TYPE_WRITE` äº‹ä»¶è¢«å¿½ç•¥
- æ²¡æœ‰å®ç° `stream_play_frame()` å‡½æ•°

---

### 3. processMessage åªä¿å­˜æ–‡ä»¶å¹¶è§¦å‘äº‹ä»¶

**æ–‡ä»¶**: `audio_streamer_glue.cpp`

```cpp
if(jsonFile) {
    // 1. ä¿å­˜ä¸º WAV æ–‡ä»¶
    std::ofstream wavFile(finalFilePath, std::ofstream::binary);
    // ... å†™å…¥æ–‡ä»¶ ...
    wavFile.close();
    
    // 2. è§¦å‘äº‹ä»¶
    m_notify(session, EVENT_PLAY, jsonString);
    
    // âŒ æ²¡æœ‰å†™å…¥æ’­æ”¾ç¼“å†²åŒº
    // âŒ æ²¡æœ‰è°ƒç”¨ä»»ä½•æ’­æ”¾å‡½æ•°
}
```

**æµç¨‹**ï¼š
```
æ¥æ”¶éŸ³é¢‘
    â†“
Float32 â†’ 16-bit PCM
    â†“
é‡é‡‡æ · 24000Hz â†’ 8000Hz
    â†“
è½¬æ¢ä¸º G.711 A-law
    â†“
ä¿å­˜ä¸ºä¸´æ—¶ WAV æ–‡ä»¶
    â†“
è§¦å‘ EVENT_PLAY äº‹ä»¶
    â†“
âŒ ç»“æŸï¼ˆæ²¡æœ‰è‡ªåŠ¨æ’­æ”¾ï¼‰
```

---

### 4. æ²¡æœ‰æ’­æ”¾ç›¸å…³çš„å‡½æ•°

**æœç´¢ç»“æœ**ï¼š
```bash
# æœç´¢æ’­æ”¾ç›¸å…³å‡½æ•°
grep -r "stream_play_frame" *.cpp *.c *.h
# ç»“æœï¼šæ— 

grep -r "switch_ivr_play" *.cpp *.c *.h
# ç»“æœï¼šæ— 

grep -r "switch_core_media_bug_write_frame" *.cpp *.c *.h
# ç»“æœï¼šæ— 
```

**ç¼ºå¤±çš„å‡½æ•°**ï¼š
- `stream_play_frame()` - æ’­æ”¾éŸ³é¢‘å¸§
- ä»»ä½•è°ƒç”¨ `switch_core_media_bug_write_frame()` çš„ä»£ç 
- ä»»ä½•è°ƒç”¨ `switch_ivr_playback()` çš„ä»£ç 

---

## å½“å‰å®ç°çš„å®Œæ•´æµç¨‹

### ä¸Šè¡Œï¼ˆå®¢æˆ·ç«¯ â†’ FreeSWITCHï¼‰

```
1. å®¢æˆ·ç«¯å‘é€ JSON æ¶ˆæ¯
   {
     "type": "streamAudio",
     "data": {
       "audioDataType": "raw",
       "sampleRate": 24000,
       "audioData": "<base64_float32>"
     }
   }
   â†“
2. processMessage() æ¥æ”¶å¹¶è§£æ
   â†“
3. Base64 è§£ç  â†’ Float32 æ•°æ®
   â†“
4. Float32 â†’ 16-bit PCM
   â†“
5. é‡é‡‡æ · 24000Hz â†’ 8000Hz
   â†“
6. 16-bit PCM â†’ G.711 A-law
   â†“
7. ä¿å­˜ä¸ºä¸´æ—¶ WAV æ–‡ä»¶
   /tmp/session_id_0.wav
   â†“
8. è§¦å‘ EVENT_PLAY äº‹ä»¶
   m_notify(session, EVENT_PLAY, jsonString)
   â†“
9. âŒ ç»“æŸï¼ˆæ²¡æœ‰è‡ªåŠ¨æ’­æ”¾ï¼‰
```

### éœ€è¦åº”ç”¨å±‚å¤„ç†

**Dialplan ç¤ºä¾‹**ï¼ˆéœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼‰ï¼š

```xml
<extension name="audio_stream_handler">
  <condition field="${Event-Name}" expression="CUSTOM">
    <condition field="${Event-Subclass}" expression="mod_audio_stream::play">
      <action application="log" data="INFO Received audio file: ${body}"/>
      <action application="playback" data="${body}"/>
    </condition>
  </condition>
</extension>
```

**æˆ–è€…ä½¿ç”¨ ESL**ï¼š

```python
import ESL

con = ESL.ESLconnection("localhost", "8021", "ClueCon")
con.events("plain", "CUSTOM mod_audio_stream::play")

while True:
    e = con.recvEvent()
    if e:
        body = e.getBody()
        # è§£æ JSON è·å–æ–‡ä»¶è·¯å¾„
        file_path = parse_json(body)['file']
        # è°ƒç”¨æ’­æ”¾
        con.api(f"uuid_broadcast {uuid} {file_path}")
```

---

## ä¸ v1.0.3 çš„å¯¹æ¯”

| ç‰¹æ€§ | å½“å‰ä»£ç  | v1.0.3ï¼ˆæ–‡æ¡£æè¿°ï¼‰ |
|------|---------|-------------------|
| **è‡ªåŠ¨æ’­æ”¾** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒ |
| **æ’­æ”¾ç¼“å†²åŒº** | âŒ æ—  | âœ… æœ‰ |
| **WRITE äº‹ä»¶å¤„ç†** | âŒ æ—  | âœ… æœ‰ |
| **æ’­æ”¾å‡½æ•°** | âŒ æ—  | âœ… stream_play_frame() |
| **æ’­æ”¾æ§åˆ¶** | âŒ æ—  | âœ… æš‚åœ/æ¢å¤/çŠ¶æ€ |
| **éœ€è¦åº”ç”¨å±‚** | âœ… æ˜¯ | âŒ å¦ |
| **å»¶è¿Ÿ** | 50-200ms | 20-40ms |
| **ç£ç›˜ I/O** | âœ… éœ€è¦ | âŒ ä¸éœ€è¦ |

---

## å¦‚ä½•ä½¿ç”¨å½“å‰ä»£ç 

### 1. å¯åŠ¨éŸ³é¢‘æµ

```javascript
uuid_audio_stream <uuid> start ws://server/path sampling=16000
```

### 2. å®¢æˆ·ç«¯å‘é€éŸ³é¢‘

```json
{
  "type": "streamAudio",
  "data": {
    "audioDataType": "raw",
    "sampleRate": 24000,
    "audioData": "<base64_float32>"
  }
}
```

### 3. ç›‘å¬ EVENT_PLAY äº‹ä»¶ï¼ˆå¿…é¡»ï¼‰

**æ–¹å¼ A: Dialplan**

```xml
<extension name="handle_audio_play">
  <condition field="${Event-Subclass}" expression="mod_audio_stream::play">
    <action application="playback" data="${body}"/>
  </condition>
</extension>
```

**æ–¹å¼ B: ESL**

```python
# ç›‘å¬äº‹ä»¶
con.events("plain", "CUSTOM mod_audio_stream::play")

# æ¥æ”¶äº‹ä»¶
e = con.recvEvent()
body = e.getBody()  # JSON åŒ…å« file è·¯å¾„

# æ’­æ”¾æ–‡ä»¶
con.api(f"uuid_broadcast {uuid} {file_path}")
```

**æ–¹å¼ C: ä½¿ç”¨ mod_event_socket**

```javascript
// Node.js ç¤ºä¾‹
esl.on('esl::event::CUSTOM::mod_audio_stream::play', (event) => {
  const body = JSON.parse(event.getBody());
  const filePath = body.file;
  
  // æ’­æ”¾æ–‡ä»¶
  esl.api(`uuid_broadcast ${uuid} ${filePath}`);
});
```

---

## æ€»ç»“

### âŒ å½“å‰ä»£ç ä¸ä¼šè‡ªåŠ¨æ’­æ”¾

**åŸå› **ï¼š
1. æ²¡æœ‰æ’­æ”¾ç¼“å†²åŒº
2. ä¸å¤„ç† WRITE äº‹ä»¶
3. æ²¡æœ‰æ’­æ”¾å‡½æ•°
4. åªä¿å­˜æ–‡ä»¶å¹¶è§¦å‘äº‹ä»¶

### âœ… éœ€è¦åº”ç”¨å±‚å¹²é¢„

**å¿…é¡»**ï¼š
- ç›‘å¬ `mod_audio_stream::play` äº‹ä»¶
- è§£æäº‹ä»¶ä¸­çš„æ–‡ä»¶è·¯å¾„
- è°ƒç”¨ `playback` æˆ– `uuid_broadcast` æ’­æ”¾æ–‡ä»¶

### ğŸ“‹ è¦å®ç°è‡ªåŠ¨æ’­æ”¾éœ€è¦

1. æ·»åŠ æ’­æ”¾ç¼“å†²åŒºå’Œäº’æ–¥é”
2. å®ç° `stream_play_frame()` å‡½æ•°
3. å¤„ç† `SWITCH_ABC_TYPE_WRITE` äº‹ä»¶
4. ä¿®æ”¹ `processMessage()` å†™å…¥æ’­æ”¾ç¼“å†²åŒº
5. æ·»åŠ æ’­æ”¾æ§åˆ¶ API

å‚è€ƒï¼š[ç›´æ¥æ’­æ”¾éŸ³é¢‘æµæ–¹æ¡ˆ.md](./ç›´æ¥æ’­æ”¾éŸ³é¢‘æµæ–¹æ¡ˆ.md)

---

## å¿«é€Ÿåˆ¤æ–­æ–¹æ³•

å¦‚æœä½ ä¸ç¡®å®šä»£ç æ˜¯å¦æ”¯æŒè‡ªåŠ¨æ’­æ”¾ï¼Œæ£€æŸ¥è¿™äº›ï¼š

```bash
# 1. æ£€æŸ¥æ•°æ®ç»“æ„
grep "play_buffer" mod_audio_stream.h
# å¦‚æœæ²¡æœ‰è¾“å‡º â†’ ä¸æ”¯æŒè‡ªåŠ¨æ’­æ”¾

# 2. æ£€æŸ¥ WRITE äº‹ä»¶å¤„ç†
grep -A 5 "SWITCH_ABC_TYPE_WRITE" mod_audio_stream.c
# å¦‚æœåªæœ‰ break; â†’ ä¸æ”¯æŒè‡ªåŠ¨æ’­æ”¾

# 3. æ£€æŸ¥æ’­æ”¾å‡½æ•°
grep "stream_play_frame\|switch_core_media_bug_write_frame" *.cpp *.c
# å¦‚æœæ²¡æœ‰è¾“å‡º â†’ ä¸æ”¯æŒè‡ªåŠ¨æ’­æ”¾
```

**å½“å‰ä»£ç çš„æ‰€æœ‰æ£€æŸ¥éƒ½è¿”å›"ä¸æ”¯æŒ"ã€‚**
